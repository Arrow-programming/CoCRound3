<!DOCTYPE html>
<!--
TODO:
Make the button that moves back to most recently placed tile
-->
<html> 
    <head>
        <!--Encoding and viewport-->
	    <meta charset="utf-8">
	    <meta name="viewport" content="width=device-width, initial-scale=1">
        <!--Import google fonts, preconnecting allows fonts to be loaded by the canvas. This is very important! It allows me to easily add text without a hacky promise method -->
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Bangers&family=Exo">
        <!--For the thumb title-->
        <link href="https://fonts.googleapis.com/css2?family=Comfortaa:wght@300..700" rel="stylesheet">
        <link rel='stylesheet' href='https://fonts.googleapis.com/css2?family=Lato&family=Material+Icons&display=swap'>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/Arrow-programming/base64/dungeon.js"></script>
        <!--The page title-->
        <title>New Webpage ;)</title>
        <!--CSS Styling-->
        <link rel="stylesheet" href="style.css" /><!-- COMBINE -->
    </head> 
    <body>
        <!--The container for the entire thing-->
        <div id="container">
            <div id="game-wrapper">
                <canvas id="game">Your browser does not support canvas</canvas>
            </div>
        </div>
        <div id="overlay">
            <button id="copyButton">Copy Score</button>
            <div id="fullscreen-container">
                <span class='material-icons' id='fullscreen'>fullscreen</span>
                <span class='material-icons' id='audio'>volume_up</span>
                <span class='material-icons' id='reload'>refresh</span>
                <span class='material-icons' id='back'>arrow_back</span>
            </div>
        </div>
        <!--All the stinkn' UI-->
        <div id="interface">
            <!--<div id = "score"></div>
            <div id="best-score">Best: 0</div>-->
            <div id="shop" class="hidden">
                <!--toggle, why don't inline functions work anymore?-->
                <div id="shop-tab">
                    <i class="material-icons" style = "margin-right: -45px">shopping_cart</i>
                </div>
    
            </div>
        </div>
        <canvas id = "thumb"></canvas>
    </body>
    
    <script src="htmlSetUp.js"></script>
    <script src="storage.js"></script>
    <script src="graphicHelpers.js"></script>
    <script src="ui.js"></script>
    <script src="audio.js"></script>
    <script src="pixelart.js"></script>
    <script src="setFastInterval.js"></script>
    <!--Having a script type of 'module' allows me to modify the document with the script tag. A blank type or module type permits the use of ES6 JS. It should be noted that the same goal can be reached by wrapping a script with a blank type in (() => {})(); which is an unnamed IIFE. -->
    <script>
(function Application() {
    const tileColors = ["#D1A593", "#45B7D1", "#6BCB77"];

    class Intro {
        constructor() {
            this.prog = 0;
            this.spdLns = [];
            this.arrowX = width / 2;
            this.textFade = 0;
        }
        run() {
            document.getElementById("interface").style.display = "none";
            ctx.lineJoin = "round";
            this.prog++;
            ctx.fillStyle = "rgba(18, 18, 18, 1)"
            ctx.fillRect(0, 0, 600, 600)
            if (this.prog < 200) {
                this.spdLns.push({
                    x: width / 2 + random(-150, 150),
                    y: -25,
                    sz: 50
                });
                for (var i = 0; i < 3; i++) {
                    var b = random(random(random(-70, 0), 0), random(0, random(0, 70)));
                    this.spdLns.push({
                        x: width / 2 + b,
                        y: height / 2 + Math.abs(b),
                        sz: 40
                    });
                }
            } else if (this.prog > 200 && this.prog < 250) {
                this.arrowX = lerp(this.arrowX, width / 2 - 80, 0.1);
            } else if (this.prog > 250 && this.prog < 320) {
                this.textFade = lerp(this.textFade, 255, 0.05);
            } else if (this.prog > 360) {
                //replace transition code as needed :)
                window.scene = "menu";
                //force menu creation immediately when intro finishes
                if (!window.menuCreated && !window.opener) {
                    createMenu();
                }
            }

            for (var i = 0; i < this.spdLns.length; i++) {
                var a = this.spdLns[i];
                ctx.fillStyle = "rgba(245, 245, 245, 1)"
                ellipse(a.x, a.y, 1, a.sz);
                a.y += 16.7;
                if (a.y > height + 25) {
                    this.spdLns.splice(i, 1);
                }
            }
            ctx.save();
            ctx.translate(this.arrowX, height / 2);
            ctx.lineWidth = 5;
            ctx.strokeStyle = `rgba(255, 255, 255, ${this.textFade/255})`;
            ctx.fillStyle = `rgba(255, 255, 255, ${1 - this.textFade/255})`;
            ctx.beginPath();
            ctx.lineTo(-50, 50);
            ctx.bezierCurveTo(-31, -16, -8, -44, 0, -54);
            ctx.bezierCurveTo(18, -37, 34, 1, 50, 51);
            ctx.bezierCurveTo(25, 13, 7, -3, 0, -9);
            ctx.bezierCurveTo(-17, 6, -44, 42, -50, 51);
            ctx.stroke();
            ctx.fill();
            ctx.closePath();

            ctx.save();
            ctx.translate(-100, -200);

            ctx.beginPath();
            ctx.lineTo(161, 237);
            ctx.bezierCurveTo(162, 211, 162, 207, 159, 203);
            ctx.lineTo(161, 208);
            ctx.bezierCurveTo(166, 201, 170, 200, 176, 208);
            ctx.stroke();
            ctx.closePath();


            ctx.beginPath();
            ctx.lineTo(190, 238);
            ctx.bezierCurveTo(191, 210, 191, 210, 188, 202);
            ctx.lineTo(192, 206);
            ctx.bezierCurveTo(196, 203, 200, 201, 207, 211);
            ctx.stroke();
            ctx.closePath();


            ctx.beginPath();
            ctx.lineTo(224, 206);
            ctx.bezierCurveTo(210, 213, 210, 225, 224, 234);
            ctx.bezierCurveTo(241, 224, 237, 210, 223, 206);
            ctx.stroke();
            ctx.closePath();


            ctx.beginPath();
            ctx.lineTo(247, 204);
            ctx.bezierCurveTo(260, 241, 260, 241, 270, 208);
            ctx.bezierCurveTo(279, 241, 279, 241, 293, 204);
            ctx.stroke();
            ctx.closePath();


            ctx.beginPath();
            ctx.lineTo(136, 168);
            ctx.bezierCurveTo(140, 171, 150, 169, 154, 171);
            ctx.stroke();
            ctx.closePath();


            ctx.beginPath();
            ctx.lineTo(142, 158);
            ctx.bezierCurveTo(143, 168, 143, 178, 145, 191);
            ctx.stroke();
            ctx.closePath();


            ctx.beginPath();
            ctx.lineTo(158, 176);
            ctx.bezierCurveTo(165, 178, 173, 178, 181, 177);
            ctx.bezierCurveTo(170, 159, 168, 159, 157, 177);
            ctx.bezierCurveTo(168, 192, 168, 192, 179, 184);
            ctx.stroke();
            ctx.closePath();

            ctx.beginPath();
            ctx.lineTo(213, 188);
            ctx.bezierCurveTo(208, 183, 212, 165, 199, 168);
            ctx.bezierCurveTo(186, 169, 187, 189, 195, 190);
            ctx.bezierCurveTo(202, 193, 206, 185, 207, 182);
            ctx.stroke();
            ctx.closePath();


            ctx.beginPath();
            ctx.lineTo(223, 191);
            ctx.bezierCurveTo(230, 159, 230, 159, 238, 192);
            ctx.bezierCurveTo(250, 160, 250, 160, 257, 191);
            ctx.stroke();
            ctx.closePath();
            ctx.restore();
            ctx.restore();

            ctx.lineJoin = "miter";
        }
    }
    let intro = new Intro();



    let roundError = 1;

    //this.drones
    let debugMode = !true;




    window.scene = "load";

    /**
     * Convert DOM screen coordinates to canvas (world) coordinates taking CSS
     * layout into account.
     * @param {number} screenX - Client X coordinate from mouse event.
     * @param {number} screenY - Client Y coordinate from mouse event.
     * @returns {{x:number,y:number}} Coordinates in canvas space.
     */

    function screenToWorld(screenX, screenY) {
        //get canvas position and dimensions
        const rect = canvas.getBoundingClientRect();

        //convert screen coords to canvas coords
        const canvasX = screenX - rect.left;
        const canvasY = screenY - rect.top;

        return {
            x: canvasX,
            y: canvasY
        };
    }

    //the game
    const Application = (function() {
        const App = function(config) {
            //self represent
            this.app = App;



            /**
             * Represents a single tile in the grid. Stores visual state and
             * provides simple update/draw helpers for smooth animation.
             */
            class Tile {
                /**
                 * Create a Tile instance.
                 * @param {number} col - Column index on the board.
                 * @param {number} row - Row index on the board.
                 * @param {number} [colorIndex=0] - Index into `tileColors` for visual color.
                 */
                constructor(col, row, colorIndex = 0) {
                    this.col = col;
                    this.row = row;
                    //0 or 1 blue or green
                    this.colorIndex = colorIndex;
                    this.x = 0;
                    this.y = 0;
                    this.targetX = 0;
                    this.targetY = 0;
                    this.matched = false;
                    this.isMoving = false;
                    this.scale = 1;
                    this.rotation = 0;
                    this.opacity = 1;
                    this.falling = false;
                    this.beingDragged = false;

                    //side indicators
                    this.sides = {
                        left: false,
                        right: false,
                        up: false,
                        down: false
                    };
                    //randomize
                    const sidesArr = ["left", "right", "up", "down"];
                    let count = Math.floor(Math.random() * 4) + 1;
                    while (count > 0) {
                        const i = Math.floor(Math.random() * sidesArr.length);
                        const s = sidesArr.splice(i, 1)[0];
                        this.sides[s] = true;
                        count--;
                    }
                }

                /**
                 * Calculate and update the tile's target position based on grid coordinates.
                 * If the tile is not currently moving, snap its displayed position to the target.
                 * @param {number} tileSize
                 * @param {number} boardX
                 * @param {number} boardY
                 * @returns {void}
                 */
                updatePosition(tileSize, boardX, boardY) {
                    this.targetX = boardX + this.col * tileSize + tileSize / 2;
                    this.targetY = boardY + this.row * tileSize + tileSize / 2;

                    if (!this.isMoving) {
                        this.x = this.targetX;
                        this.y = this.targetY;
                    }
                }

                /**
                 * Progress the tile's animation toward its target position and
                 * update visual properties such as `scale` and `opacity`.
                 * @param {number} dt - Delta time in seconds since last frame.
                 * @returns {void}
                 */
                animate(dt) {
                    //dont animate while user is dragging this tile
                    if (this.beingDragged) return;

                    //move with predictable per-axis speed to avoid jerk
                    const maxSpeedY = 1200;
                    const maxSpeedX = 1000;

                    const dy = this.targetY - this.y;
                    const dx = this.targetX - this.x;

                    const stepY = Math.sign(dy) * Math.min(Math.abs(dy), maxSpeedY * dt);
                    const stepX = Math.sign(dx) * Math.min(Math.abs(dx), maxSpeedX * dt);

                    this.x += stepX;
                    this.y += stepY;

                    const dist = Math.hypot(dx - stepX, dy - stepY);
                    const stopThreshold = Math.max(0.5, 8 * dt);
                    if (Math.abs(dx) <= stopThreshold && Math.abs(dy) <= stopThreshold) {
                        this.x = this.targetX;
                        this.y = this.targetY;
                        this.isMoving = false;
                    } else {
                        this.isMoving = true;
                    }

                    //smooth scale back to 1
                    if (this.scale > 1) {
                        const scaleSpeed = 6;
                        const delta = (1 - this.scale) * (1 - Math.exp(-scaleSpeed * dt));
                        this.scale += delta;
                        if (this.scale < 1.01) this.scale = 1;
                    }

                    if (this.matched) {
                        this.scale *= 0.95;
                        this.opacity *= 0.9;
                    }
                }

                /**
                 * Render the tile to the global `ctx` canvas context.
                 * @param {number} tileSize - Size used for drawing calculations.
                 * @param {boolean} [isDragging=false] - Whether the tile is currently being dragged (affects styling).
                 * @returns {void}
                 */
                // draw(tileSize, isDragging = false) {
                //     ctx.globalAlpha = this.opacity;
                //     ctx.save();
                //     ctx.translate(this.x, this.y);
                //     ctx.scale(this.scale, this.scale);
                //     ctx.rotate(this.rotation);

                //     const cornerRadius = 8;
                //     const bgSize = tileSize * 0.48;
                //     const fillColor = tileColors[this.colorIndex % tileColors.length];

                //     //background rounded rect
                //     ctx.fillStyle = fillColor;
                //     ctx.beginPath();
                //     ctx.moveTo(-bgSize + cornerRadius, -bgSize);
                //     ctx.lineTo(bgSize - cornerRadius, -bgSize);
                //     ctx.quadraticCurveTo(bgSize, -bgSize, bgSize, -bgSize + cornerRadius);
                //     ctx.lineTo(bgSize, bgSize - cornerRadius);
                //     ctx.quadraticCurveTo(bgSize, bgSize, bgSize - cornerRadius, bgSize);
                //     ctx.lineTo(-bgSize + cornerRadius, bgSize);
                //     ctx.quadraticCurveTo(-bgSize, bgSize, -bgSize, bgSize - cornerRadius);
                //     ctx.lineTo(-bgSize, -bgSize + cornerRadius);
                //     ctx.quadraticCurveTo(-bgSize, -bgSize, -bgSize + cornerRadius, -bgSize);
                //     ctx.closePath();
                //     ctx.fill();

                //     ctx.strokeStyle = isDragging ? "rgba(255,255,180,0.9)" : "rgba(255,255,255,0.6)";
                //     ctx.lineWidth = isDragging ? 3 : 2;
                //     ctx.stroke();

                //     //draw small red indicators on sides
                //     ctx.fillStyle = "#D9534F";
                //     const indLen = tileSize * 0.22;
                //     const indW = Math.max(3, Math.round(tileSize * 0.06));
                //     if (this.sides.up) {
                //         ctx.fillRect(-indLen / 2, -bgSize + 6, indLen, indW);
                //     }
                //     if (this.sides.down) {
                //         ctx.fillRect(-indLen / 2, bgSize - 6 - indW, indLen, indW);
                //     }
                //     if (this.sides.left) {
                //         ctx.fillRect(-bgSize + 6, -indLen / 2, indW, indLen);
                //     }
                //     if (this.sides.right) {
                //         ctx.fillRect(bgSize - 6 - indW, -indLen / 2, indW, indLen);
                //     }

                //     ctx.restore();
                //     ctx.globalAlpha = 1;
                // }
                draw(tileSize, isDragging = false) {
                    PixelArt.draw(
                        ctx,
                        this.colorIndex,
                        this.sides,
                        this.x, this.y,
                        tileSize,
                        this.opacity,
                        this.scale,
                        isDragging
                    );
                }
            }

            /**
             * Small left-side pool of tiles (spare tiles). Manages positions for
             * pooled tiles and supports dragging from the pool.
             */
            class TilePool {
                /**
                 * Create a TilePool to hold spare tiles displayed beside the board.
                 * @param {number} tileSize
                 * @param {number} [left=10]
                 * @param {number} [top=10]
                 * @param {Object} [parent=null] - Reference to parent TileBoard for board coordinates and right grid.
                 */
                constructor(tileSize, left = 10, top = 10, parent = null) {
                    this.tileSize = tileSize;
                    this.left = left;
                    this.top = top;
                    this.padding = 8;
                    this.spacing = 10;
                    this.tiles = [];
                    this.selectedTile = null;
                    this.draggedTile = null;
                    this.draggedTileOriginal = null;
                    this.dragOffsetX = 0;
                    this.dragOffsetY = 0;
                    this.invalidDrop = false;
                    this.invalidDropTile = null;
                    this.invalidDropTime = 0;
                    this.parent = parent;
                }

                /**
                 * Compute the drawing target position for a pooled slot index.
                 * @param {number} slot
                 * @returns {{x:number,y:number}}
                 */
                getTarget(slot) {
                    const x = this.left + slot * this.spacing + this.tileSize / 2;
                    const y = this.top + this.tileSize / 2;
                    return {
                        x,
                        y
                    };
                }

                /**
                 * Add a tile to the end of the pool and position it.
                 * @param {Tile} tile
                 * @returns {void}
                 */
                add(tile) {
                    const slot = this.tiles.length;
                    tile.poolIndex = slot;
                    tile.inPool = true;
                    tile.toBePooled = false;
                    tile.isMoving = false;
                    tile.beingDragged = false;
                    tile.matched = false;
                    tile.scale = 1;
                    tile.opacity = 1;
                    tile.rotation = 0;

                    const t = this.getTarget(slot);
                    tile.x = t.x;
                    tile.y = t.y;
                    tile.targetX = t.x;
                    tile.targetY = t.y;
                    this.tiles.push(tile);
                }

                /**
                 * Insert a tile at the specified pool index, shifting others.
                 * @param {Tile} tile
                 * @param {number} idx
                 * @returns {void}
                 */
                insertAt(tile, idx) {
                    //insert back into pool at index and renumber
                    this.tiles.splice(idx, 0, tile);
                    for (let i = 0; i < this.tiles.length; i++) {
                        const p = this.tiles[i];
                        p.poolIndex = i;
                        const t = this.getTarget(i);
                        p.targetX = t.x;
                        p.targetY = t.y;
                        p.isMoving = true;
                    }
                }

                /**
                 * Remove a tile from the pool and re-layout remaining tiles.
                 * @param {Tile} tile
                 * @returns {void}
                 */
                remove(tile) {
                    const idx = this.tiles.indexOf(tile);
                    if (idx >= 0) this.tiles.splice(idx, 1);
                    //renumber remaining
                    for (let i = 0; i < this.tiles.length; i++) {
                        const p = this.tiles[i];
                        p.poolIndex = i;
                        const { x, y } = this.getTarget(i);
                        p.targetX = x;
                        p.targetY = y;
                        p.isMoving = true;
                    }
                }

                /**
                 * Find a pooled tile at the given world coordinates (center-based hit test).
                 * @param {number} x
                 * @param {number} y
                 * @returns {Tile|null}
                 */
                getTileAtPos(x, y) {
                    //tile "radius" (half the side length, very convenient for center coordinates)
                    const rad = this.tileSize / 2;

                    //check tiles in backwards order, because that's front to back
                    for (let i = this.tiles.length - 1; i >= 0; i--) {
                        const {
                            x: tileX,
                            y: tileY
                        } = this.getTarget(i);
                        if (
                            x > tileX - rad && x < tileX + rad &&
                            y > tileY - rad && y < tileY + rad
                        ) {
                            return this.tiles[i];
                        }
                    }
                    return null;
                }

                /**
                 * Handle pointer input for starting, updating, and ending drags on pooled tiles.
                 * Reads global `mouse` state and updates pool/tiles accordingly.
                 * @returns {void}
                 */
                handleInput() {
                    const {
                        screenX,
                        screenY,
                        down,
                        wasDown
                    } = mouse;
                    const clickHappened = down && !wasDown;
                    const released = !down && wasDown;

                    if (clickHappened) {
                        const {
                            x: scaledX,
                            y: scaledY
                        } = screenToWorld(screenX, screenY);
                        const tile = this.getTileAtPos(scaledX, scaledY);
                        if (tile) {
                            this.draggedTile = tile;
                            this.draggedTile.beingDragged = true;
                            this.draggedTileOriginal = {
                                x: tile.x,
                                y: tile.y,
                                row: tile.row,
                                col: tile.col
                            };
                            this.dragOffsetX = scaledX - tile.x;
                            this.dragOffsetY = scaledY - tile.y;
                        }
                    } else if (this.draggedTile && down) {
                        const {
                            x: scaledX,
                            y: scaledY
                        } = screenToWorld(screenX, screenY);
                        const targetX = scaledX - this.dragOffsetX;
                        const targetY = scaledY - this.dragOffsetY;
                        [this.draggedTile.x, this.draggedTile.y] = [targetX, targetY];

                        const distFromStart = Math.hypot(
                            this.draggedTile.x - this.draggedTileOriginal.x,
                            this.draggedTile.y - this.draggedTileOriginal.y
                        );
                        const maxDragDist = this.tileSize * 1.2;
                        const sizeProgress = Math.min(distFromStart / maxDragDist, 1);
                        this.draggedTile.scale = 1 + (sizeProgress * 0.3);

                    } else if (released && this.draggedTile) {
                        let placed = false;

                        //use window.App.rightGrid
                        if (window.App && window.App.rightGrid) {
                            const placeCell = window.App.rightGrid.getCellAtPos(
                                this.draggedTile.x, this.draggedTile.y
                            );
                            if (placeCell) {
                                //try to place into the grid
                                const ok = window.App.rightGrid.placeTile(this.draggedTile, placeCell.col, placeCell.row);
                                if (ok) {
                                    //remove from pool only when placement succeeded
                                    this.remove(this.draggedTile);
                                    placed = true;
                                    this.draggedTile.beingDragged = false;
                                    this.draggedTile.scale = 1;
                                    this.draggedTile = null;
                                    this.draggedTileOriginal = null;
                                    return;
                                }
                                //else tile goes to in pool
                            }
                        }

                        if (!placed) {
                            this.invalidDrop = true;
                            this.invalidDropTile = this.draggedTile;
                            this.invalidDropTime = 0;
                            this.invalidDropTile.targetX = this.draggedTileOriginal.x;
                            this.invalidDropTile.targetY = this.draggedTileOriginal.y;
                            this.invalidDropTile.isMoving = true;
                        }

                        if (this.draggedTile) this.draggedTile.beingDragged = false;
                        if (this.draggedTile) this.draggedTile.scale = 1;
                        this.draggedTile = null;
                        this.draggedTileOriginal = null;
                    }
                }

                /**
                 * Update pool-level timed state (e.g. invalid-drop animations).
                 * @param {number} dt - Delta time in seconds.
                 * @returns {void}
                 */
                update(dt) {
                    if (this.invalidDrop && this.invalidDropTile) {
                        this.invalidDropTime += dt;
                        const tile = this.invalidDropTile;
                        const dist = Math.hypot(tile.targetX - tile.x, tile.targetY - tile.y);

                        tile.animate(dt);

                        //when tile reaches original position, clear invalid swap
                        if (dist < 2) {
                            this.invalidDrop = false;
                            this.invalidDropTile = null;
                            this.invalidDropTime = 0;
                        }
                    }
                    for (const tile of this.tiles) {
                        if (tile.isMoving) {
                            tile.animate(dt);
                        }
                    }
                }
            }

            /**
             * The main tile board class. This is shaped like a rectangle, except
             * the bottom right is taken out. This stores a 2D array of `Tile` objects,
             * handles swapping, gravity, match detection, and board updates.
             */
            class TileBoard {
                /**
                 * Create a TileBoard that manages the grid of tiles and game mechanics.
                 * @param {number} [cols1=6]
                 * @param {number} [rows1=12] 
                 * @param {number} [cols2=6]
                 * @param {number} [rows2=6]
                 * @param {number} [boardX=20]
                 * @param {number} [boardY=120]
                 * @param {number} [tileSize=85]
                 */
                constructor(cols1 = 6, rows1 = 12, cols2 = 6, rows2 = 6, boardX = 20, boardY = 120, tileSize = 85) {
                    this.cols1 = cols1;
                    this.rows1 = rows1;
                    this.cols2 = cols2;
                    this.rows2 = rows2;
                    this.cols = this.cols1 + this.cols2;
                    this.rows = this.rows1;
                    this.boardX = boardX;
                    this.boardY = boardY;
                    this.tileSize = tileSize;
                    this.tiles = Array.from({
                        length: this.rows1
                    }).map(e => []);
                    this.pool = new TilePool(this.tileSize, 12, 12, this);
                    this.selectedTile = null;
                    this.draggedTile = null;
                    this.draggedTileOriginal = null;
                    this.dragOffsetX = 0;
                    this.dragOffsetY = 0;
                    this.scores = 0;
                    this.matchesThisFrame = 0;
                    this.swapInProgress = false;
                    this.invalidSwap = false;
                    this.invalidSwapTile = null;
                    this.invalidSwapTime = 0;
                    this.lastMousePos = {
                        x: 0,
                        y: 0
                    };
                    //{ tile1, tile2 } when user swaps
                    this.pendingUserSwap = null;
                    //store reversing pair
                    this.reversingSwap = null;
                    //set true when reverse animation running
                    this.justReversed = false;

                    this.initBoard();
                }

                /**
                 * Initialize or regenerate the board until no initial matches exist
                 * and at least one possible move is present.
                 * @returns {void}
                 */
                // initBoard() {
                //     // fill board regenerate entire board until no initial connected matches exist
                //     this.iterate((row, col) => {
                //         const colorIndex = Math.floor(Math.random() * tileColors.length);
                //         const tile = new Tile(col, row, colorIndex);
                //         tile.updatePosition(this.tileSize, this.boardX, this.boardY);
                //         this.tiles[row][col] = tile;
                //         // tag tile with board ref. This allows me to have multiple boards that work together
                //         tile.board = this;
                //     });
                // }
                initBoard() {
                    let attempts = 0;
                    do {
                        this.iterate((row, col) => {
                            const colorIndex = Math.floor(Math.random() * tileColors.length);
                            const tile = new Tile(col, row, colorIndex);
                            tile.updatePosition(this.tileSize, this.boardX, this.boardY);
                            this.tiles[row][col] = tile;
                            tile.board = this;
                        });
                        attempts++;
                        if (attempts > 200) break;
                    } while (this.findMatches().length > 0 || !this.hasPossibleMove());
                }

                /** Iterates a function through a TileBoard.
                 * 
                 * @param {(r, c) => *} callback
                 * @returns {void}
                 */
                iterate(callback) {
                    for (let r = 0; r < this.rows; r++) {
                        const cols = r < this.rows2 ? this.cols : this.cols1;
                        for (let c = 0; c < cols; c++) {
                            callback(r, c);
                        }
                    }
                }

                // initial board will be regenerated if any connected matches are present
                /**
                 * Check whether a tile placement is valid. Placeholder that currently always returns true.
                 * @param {number} col
                 * @param {number} row
                 * @returns {boolean}
                 */
                isTileValid(col, row) {
                    return true; // HELP: btw what is this supposed to do, if it checks if in bounds then my function below does just that
                }

                /**
                 * Checks if tile row and col is in bounds.
                 * @param {number} row
                 * @param {number} col
                 * @returns {boolean} 
                 */
                inBounds(row, col) {
                    return (
                        row >= 0 && col >= 0 && (
                            (row < this.rows2 && col < this.cols) ||
                            (row < this.rows && col < this.cols1)
                        )
                    );
                }

                /**
                 * Return the tile at world coordinates, or null if none.
                 * @param {number} x
                 * @param {number} y
                 * @returns {Tile|null}
                 */
                getTileAtPos(x, y) {
                    const col = Math.floor((x - this.boardX) / this.tileSize);
                    const row = Math.floor((y - this.boardY) / this.tileSize);

                    if (this.inBounds(row, col)) return this.tiles[row][col];
                    return null;
                }

                /**
                 * Handle selection of a tile. If a different tile is already selected,
                 * attempt to swap if adjacent.
                 * @param {Tile} tile
                 * @returns {void}
                 */
                selectTile(tile) {
                    if (this.swapInProgress) return;

                    if (this.selectedTile === tile) {
                        this.selectedTile = null;
                    } else if (!this.selectedTile) {
                        this.selectedTile = tile;
                    } else {
                        //swap tiles if adjacent
                        if (this.areAdjacent(this.selectedTile, tile)) {
                            //mark as a user-initiated swap so we can check after animation
                            this.pendingUserSwap = {
                                tile1: this.selectedTile,
                                tile2: tile
                            };
                            this.swapTiles(this.selectedTile, tile);
                        }
                        this.selectedTile = tile;
                    }
                }

                /**
                 * Test whether two tiles are adjacent on the grid.
                 * @param {Tile} tile1
                 * @param {Tile} tile2
                 * @returns {boolean}
                 */
                areAdjacent(tile1, tile2) {
                    const colDiff = Math.abs(tile1.col - tile2.col);
                    const rowDiff = Math.abs(tile1.row - tile2.row);
                    return (colDiff === 1 && rowDiff === 0) || (colDiff === 0 && rowDiff === 1);
                }

                /**
                 * Swap two tiles in the grid and set them moving toward updated targets.
                 * @param {Tile} tile1
                 * @param {Tile} tile2
                 * @returns {void}
                 */
                swapTiles(tile1, tile2) {
                    //swap positions in grid
                    [this.tiles[tile1.row][tile1.col], this.tiles[tile2.row][tile2.col]] = [this.tiles[tile2.row][tile2.col], this.tiles[tile1.row][tile1.col]];

                    //store original data before swapping properties
                    const originalRow1 = tile1.row;
                    const originalCol1 = tile1.col;

                    //swap row/col properties
                    tile1.row = tile2.row;
                    tile1.col = tile2.col;
                    tile2.row = originalRow1;
                    tile2.col = originalCol1;

                    //ensure tiles animate towards their targets
                    tile1.isMoving = true;
                    tile2.isMoving = true;

                    //update target positions (animation will move from current x/y)
                    tile1.updatePosition(this.tileSize, this.boardX, this.boardY);
                    tile2.updatePosition(this.tileSize, this.boardX, this.boardY);

                    this.swapInProgress = true;
                }

                /**
                 * Reverse a previously performed swap (animation-aware).
                 * @param {Tile} tile1
                 * @param {Tile} tile2
                 * @returns {void}
                 */
                reverseSwap(tile1, tile2) {
                    //reverse a swap with animation
                    [this.tiles[tile1.row][tile1.col], this.tiles[tile2.row][tile2.col]] = [this.tiles[tile2.row][tile2.col], this.tiles[tile1.row][tile1.col]];

                    const originalRow1 = tile1.row;
                    const originalCol1 = tile1.col;

                    tile1.row = tile2.row;
                    tile1.col = tile2.col;
                    tile2.row = originalRow1;
                    tile2.col = originalCol1;

                    //ensure reverse animates
                    tile1.isMoving = true;
                    tile2.isMoving = true;

                    tile1.updatePosition(this.tileSize, this.boardX, this.boardY);
                    tile2.updatePosition(this.tileSize, this.boardX, this.boardY);

                    //mark that we've initiated a reverse so update() can handle end-of-animation cleanup
                    this.justReversed = true;
                    this.swapInProgress = true;
                }

                /**
                 * Find connected components of tiles that satisfy matching rules.
                 * Returns an array of matched tiles.
                 * @returns {Tile[]}
                 */
                findMatches() {
                    // find connected components where tiles have same color and both have indicators on the touching side
                    const matched = [];
                    const visited = Array.from({
                        length: this.rows2
                    }, () => Array(this.cols).fill(false)).concat(
                        Array.from({
                            length: this.rows
                        }, () => Array(this.cols1).fill(false))
                    );

                    this.iterate((r, c) => {
                        const start = this.tiles[r][c];
                        if (!start || visited[r][c]) return;

                        const color = start.colorIndex;
                        const stack = [start];
                        const component = [];

                        while (stack.length) {
                            const t = stack.pop();
                            const tr = t.row;
                            const tc = t.col;
                            if (visited[tr][tc]) continue;
                            visited[tr][tc] = true;
                            component.push(t);

                            //check four neighbors for bidirectional (fun word lol) indicator connection
                            const neighbors = [{
                                    rr: tr - 1,
                                    cc: tc,
                                    side: 'up',
                                    opp: 'down'
                                },
                                {
                                    rr: tr + 1,
                                    cc: tc,
                                    side: 'down',
                                    opp: 'up'
                                },
                                {
                                    rr: tr,
                                    cc: tc - 1,
                                    side: 'left',
                                    opp: 'right'
                                },
                                {
                                    rr: tr,
                                    cc: tc + 1,
                                    side: 'right',
                                    opp: 'left'
                                }
                            ];

                            for (const n of neighbors) {
                                if (!this.inBounds(n.rr, n.cc)) continue;
                                const nb = this.tiles[n.rr][n.cc];
                                if (!nb) continue;
                                if (visited[n.rr][n.cc]) continue;
                                if (nb.colorIndex !== color) continue;

                                //both tiles must have indicators on the contacting sides
                                if (t.sides[n.side] && nb.sides[n.opp]) {
                                    stack.push(nb);
                                }
                            }
                        }

                        if (component.length >= 3) {
                            //limit match removal to a maximum of 3 tiles per connected component
                            const toAdd = component.slice(0, 3);
                            for (const tile of toAdd) matched.push(tile);
                        }
                    });

                    return matched;
                }

                /**
                 * Mark matched tiles for pooling and initiate their movement into the pool.
                 * @returns {void}
                 */
                handleMatches(matched) {
                    if (!matched) {
                        matched = this.findMatches();
                    }
                    if (matched.length === 0) {
                        this.swapInProgress = false;
                        return;
                    }

                    matched.forEach(tile => {
                        tile.matched = true;
                        tile.toBePooled = true;
                        tile.inPool = false;
                        tile.isMoving = false;
                    });

                    if (window.App && matched.length >= 3) {
                        window.App.addShake(matched.length * 0.8);
                    }

                    //track next slot per owner separately so tiles don't stack
                    const ownerSlots = new Map();
                    matched.forEach(tile => {
                        const owner = tile.board || this;
                        const slot = ownerSlots.has(owner) ? ownerSlots.get(owner) : owner.pool.tiles.length;
                        ownerSlots.set(owner, slot + 1);
                        const t = owner.pool.getTarget(slot);
                        tile.targetX = t.x;
                        tile.targetY = t.y;
                        tile.isMoving = true;
                        tile.rotation = 0;
                        owner.swapInProgress = true;
                    });

                    this.swapInProgress = true;
                }

                /**
                 * Apply gravity to the board so tiles fall down into empty spaces.
                 * @returns {void}
                 */
                applyGravity() {
                    for (let col = 0; col < this.cols; col++) {
                        let writePos = this.rows - 1;

                        for (let row = this.rows - 1; row >= 0; row--) {
                            if (this.tiles[row][col] !== null) {
                                if (row !== writePos) {
                                    this.tiles[writePos][col] = this.tiles[row][col];
                                    this.tiles[writePos][col].row = writePos;
                                    //mark as moving so updatePosition does not snap them
                                    this.tiles[writePos][col].isMoving = true;
                                    this.tiles[row][col] = null;
                                }
                                writePos--;
                            }
                        }
                    }

                    //update positions
                    for (let row = 0; row < this.rows; row++) {
                        for (let col = 0; col < this.cols; col++) {
                            if (this.tiles[row][col]) {
                                this.tiles[row][col].updatePosition(
                                    this.tileSize, this.boardX, this.boardY
                                );
                            }
                        }
                    }
                }

                /**
                 * Fill empty slots on the board by creating new tiles and then check for cascades.
                 * @returns {void}
                 */
                fillGaps() {
                    for (let col = 0; col < this.cols; col++) {
                        for (let row = 0; row < this.rows; row++) {
                            if (this.tiles[row][col] === null) {
                                const colorIndex = Math.floor(Math.random() * tileColors.length);
                                const tile = new Tile(col, row, colorIndex);
                                tile.y = this.boardY - this.tileSize;
                                tile.targetY = this.boardY + row * this.tileSize + this.tileSize / 2;
                                tile.targetX = this.boardX + col * this.tileSize + this.tileSize / 2;
                                tile.x = tile.targetX;
                                this.tiles[row][col] = tile;
                                //same as initBoard:
                                tile.board = this;
                            }
                        }
                    }

                }

                /**
                 * Determine whether there exists at least one legal adjacent swap that would create a match.
                 * @returns {boolean}
                 */
                hasPossibleMove() {
                    //returns true if there exists at least one adjacent swap that would create a match
                    const inBounds = (r, c) => r >= 0 && r < this.rows && c >= 0 && c < this.cols;

                    for (let r = 0; r < this.rows; r++) {
                        for (let c = 0; c < this.cols; c++) {
                            const t = this.tiles[r][c];
                            if (!t) continue;

                            //check right neighbor
                            const rc = c + 1;
                            if (rc < this.cols) {
                                const t2 = this.tiles[r][rc];
                                if (t2) {
                                    //swap inplace
                                    this.tiles[r][c] = t2;
                                    this.tiles[r][rc] = t;
                                    const origR1 = t.row,
                                        origC1 = t.col,
                                        origR2 = t2.row,
                                        origC2 = t2.col;
                                    t.row = r;
                                    t.col = rc;
                                    t2.row = r;
                                    t2.col = c;

                                    const matches = this.findMatches();

                                    //swap back
                                    this.tiles[r][c] = t;
                                    this.tiles[r][rc] = t2;
                                    t.row = origR1;
                                    t.col = origC1;
                                    t2.row = origR2;
                                    t2.col = origC2;

                                    if (matches.length > 0) return true;
                                }
                            }

                            //check down neighbor
                            const rr = r + 1;
                            if (rr < this.rows) {
                                const t2 = this.tiles[rr][c];
                                if (t2) {
                                    this.tiles[r][c] = t2;
                                    this.tiles[rr][c] = t;
                                    const origR1 = t.row,
                                        origC1 = t.col,
                                        origR2 = t2.row,
                                        origC2 = t2.col;
                                    t.row = rr;
                                    t.col = c;
                                    t2.row = r;
                                    t2.col = c;

                                    const matches = this.findMatches();

                                    this.tiles[r][c] = t;
                                    this.tiles[rr][c] = t2;
                                    t.row = origR1;
                                    t.col = origC1;
                                    t2.row = origR2;
                                    t2.col = origC2;

                                    if (matches.length > 0) return true;
                                }
                            }
                        }
                    }

                    return false;
                }

                /**
                 * Randomly shuffle tiles until a solvable board (no immediate matches and at least one possible move) is produced.
                 * @returns {void}
                 */
                reshuffleBoard() {
                    //flatten tiles
                    const list = [];
                    for (let r = 0; r < this.rows; r++) {
                        for (let c = 0; c < this.cols; c++) {
                            if (this.tiles[r][c]) list.push(this.tiles[r][c]);
                        }
                    }

                    //try shuffling until a solvable board (no immediate matches and hasPossibleMove)
                    const shuffleArray = (a) => {
                        for (let i = a.length - 1; i > 0; i--) {
                            const j = Math.floor(Math.random() * (i + 1));
                            [a[i], a[j]] = [a[j], a[i]];
                        }
                    };

                    let attempts = 0;
                    do {
                        shuffleArray(list);
                        //reassign
                        let idx = 0;
                        for (let r = 0; r < this.rows; r++) {
                            for (let c = 0; c < this.cols; c++) {
                                const t = list[idx++];
                                this.tiles[r][c] = t || null;
                                if (t) {
                                    t.row = r;
                                    t.col = c;
                                    t.updatePosition(this.tileSize, this.boardX, this.boardY);
                                    t.x = t.targetX;
                                    t.y = t.targetY;
                                    t.isMoving = false;
                                }
                            }
                        }
                        attempts++;
                        if (attempts > 200) break;
                    } while (this.findMatches().length > 0 || !this.hasPossibleMove());
                }

                /**
                 * Update board state: animate tiles, detect pooling completions, handle swaps and matches.
                 * @param {number} dt - Delta time in seconds.
                 * @returns {void}
                 */
                update(dt) {
                    // update all tiles
                    this.iterate((row, col) => this.tiles[row][col].animate(dt));

                    // check for tiles that finished animating into the pool and move them from grid to pool
                    let pooledThisFrame = [];
                    this.iterate((row, col) => {
                        const t = this.tiles[row][col];
                        if (t && t.toBePooled && !t.isMoving && !t.inPool) {
                            //remove from grid and add to pool
                            this.tiles[row][col] = null;
                            t.inPool = true;
                            t.toBePooled = false;
                            //ensure position remains at pool target
                            t.x = t.targetX;
                            t.y = t.targetY;
                            this.pool.add(t);
                            pooledThisFrame.push(t);
                        }
                    });

                    if (pooledThisFrame.length > 0) {
                        this.applyGravity();
                        this.fillGaps();
                        // don't interupt 
                        this.swapInProgress = true;
                    }

                    // handle invalid swap completion
                    if (this.invalidSwap && this.invalidSwapTile) {
                        this.invalidSwapTime += dt;
                        const tile = this.invalidSwapTile;
                        const dist = Math.hypot(tile.targetX - tile.x, tile.targetY - tile.y);

                        //when tile reaches original position, clear invalid swap
                        if (dist < 2) {
                            this.invalidSwap = false;
                            this.invalidSwapTile = null;
                            this.invalidSwapTime = 0;
                        }
                    }

                    //only check for matches after all tiles have finished falling
                    let anyMoving = false;
                    this.iterate((row, col) => {
                        if (this.tiles[row][col] && this.tiles[row][col].isMoving) {
                            anyMoving = true;
                        }
                    });

                    if (!anyMoving && this.swapInProgress) {
                        //if this was a user-initiated swap, check its result after the visual swap and grav settles
                        if (this.pendingUserSwap) {
                            const matches = this.findMatches();
                            if (matches.length > 0) {
                                //valid swap so clear pending and handle matches normally
                                this.pendingUserSwap = null;
                                //pass in
                                this.handleMatches(matches);
                            } else {
                                //invalid swap so reverse with animation and show invalid overlay
                                const t1 = this.pendingUserSwap.tile1;
                                const t2 = this.pendingUserSwap.tile2;
                                this.pendingUserSwap = null;
                                this.invalidSwap = true;
                                this.invalidSwapTile = t1;
                                this.invalidSwapTime = 0;
                                this.reversingSwap = {
                                    tile1: t1,
                                    tile2: t2
                                };
                                this.reverseSwap(t1, t2);
                                if (window.App) window.App.addShake(2.5);
                            }
                        } else if (this.justReversed) {
                            //finished reversing an invalid swap clear flags
                            this.swapInProgress = false;
                            this.justReversed = false;
                            this.invalidSwap = false;
                            this.invalidSwapTile = null;
                            this.invalidSwapTime = 0;
                            this.reversingSwap = null;
                        } else {
                            //check for cascade matches after gravity settles
                            const matches = this.findMatches();
                            if (matches.length > 0) {
                                //pass in baby
                                this.handleMatches(matches);
                            } else {
                                if (!this.hasPossibleMove()) this.reshuffleBoard();
                                this.swapInProgress = false;
                            }
                        }
                    }
                }

                /**
                 * Render the board, grid, pooled tiles, and visual feedback to the global `ctx`.
                 * @returns {void}
                 */
                draw() {
                    //draw board background
                    ctx.fillStyle = "rgba(224, 221,211,255)";
                    ctx.fillRect(
                        this.boardX - 5,
                        this.boardY - 5,
                        this.cols1 * this.tileSize + 10,
                        this.rows1 * this.tileSize + 10
                    );
                    ctx.fillRect(
                        this.boardX + this.cols1 * this.tileSize + 5,
                        this.boardY - 5,
                        this.cols2 * this.tileSize,
                        this.rows2 * this.tileSize + 10
                    );

                    
                    //draw grid lines
                    //ctx.strokeStyle = "rgba(10, 10, 150, 0.3)";
                    //ctx.lineWidth = 1;
                    // for (let i = 0; i <= this.cols; i++) {  
                    //     ctx.beginPath();
                    //     ctx.moveTo(this.boardX + i * this.tileSize, this.boardY);
                    //     ctx.lineTo(
                    //         this.boardX + i * this.tileSize,
                    //         this.boardY + (i <= this.cols1 ? this.rows : this.rows2) * this.tileSize
                    //     );
                    //     ctx.stroke();
                    // }      
                    // for (let i = 0; i <= this.rows1; i++) {
                    //     ctx.beginPath();
                    //     ctx.moveTo(this.boardX, this.boardY + i * this.tileSize);
                    //     ctx.lineTo(
                    //         this.boardX + (i <= this.rows2 ? this.cols : this.cols1) * this.tileSize,
                    //         this.boardY + i * this.tileSize
                    //     );
                    //     ctx.stroke();
                    // }

                    //draw tiles
                    this.iterate((row, col) => {
                        const tile = this.tiles[row][col];
                        if (tile && tile != this.draggedTile) {
                            tile.draw(this.tileSize, false);
                        }
                    });

                    // draw dragged tile   
                    if (this.draggedTile) this.draggedTile.draw(this.tileSize, true);

                    //draw pool area
                    const poolTop = 6;
                    const poolHeight = this.tileSize + 18;
                    ctx.save();
                    ctx.fillStyle = "rgba(224,221,211,255)";
                    ctx.fillRect(0, poolTop, width, poolHeight);
                    ctx.globalAlpha = 1;
                    ctx.restore();

                    //draw pooled tiles
                    for (let i = 0; i < this.pool.tiles.length; i++) {
                        const tile = this.pool.tiles[i];
                        //ensure pooled tiles use pool visuals and are drawn above
                        tile.draw(this.tileSize, false);
                    }

                    //draw invalid swap feedback
                    if (this.invalidSwap && this.invalidSwapTile) {
                        const flashIntensity = Math.max(0, 1 - (this.invalidSwapTime / 0.3));
                        const alphaFlash = flashIntensity * 0.4;

                        ctx.fillStyle = `rgba(255, 80, 80, ${alphaFlash})`;
                        ctx.fillRect(
                            this.boardX - 5,
                            this.boardY - 5,
                            this.cols * this.tileSize + 10,
                            this.rows * this.tileSize + 10
                        );
                    }
                }

                /**
                 * Handle mouse/touch input for selecting, dragging and dropping tiles on the board.
                 * Reads global `mouse` state.
                 * @returns {void}
                 */
                handleInput() {
                    const {
                        screenX,
                        screenY,
                        down,
                        wasDown
                    } = mouse;
                    //detect drag 
                    const clickHappened = down && !wasDown;
                    const released = !down && wasDown;
                    if (clickHappened) {
                        //start dragging a tile use global screenToWorld function
                        const worldPos = screenToWorld(screenX, screenY);
                        const scaledX = worldPos.x;
                        const scaledY = worldPos.y;

                        const tile = this.getTileAtPos(scaledX, scaledY);
                        if (tile && !this.swapInProgress && !this.invalidSwap) {
                            this.draggedTile = tile;
                            this.draggedTile.beingDragged = true;
                            this.draggedTileOriginal = {
                                x: tile.x,
                                y: tile.y,
                                row: tile.row,
                                col: tile.col
                            };
                            this.dragOffsetX = scaledX - tile.x;
                            this.dragOffsetY = scaledY - tile.y;
                        }
                    } else if (this.draggedTile && down) {
                        //update drag position
                        const worldPos = screenToWorld(screenX, screenY);
                        const scaledX = worldPos.x;
                        const scaledY = worldPos.y;

                        const targetX = scaledX - this.dragOffsetX;
                        const targetY = scaledY - this.dragOffsetY;

                        //directly set position
                        this.draggedTile.x = targetX;
                        this.draggedTile.y = targetY;

                        //calc distance from original and apply size curve
                        const distFromStart = Math.hypot(
                            this.draggedTile.x - this.draggedTileOriginal.x,
                            this.draggedTile.y - this.draggedTileOriginal.y
                        );

                        //size grows as drag distance increases (easing function)
                        const maxDragDist = this.tileSize * 1.2;
                        const sizeProgress = Math.min(distFromStart / maxDragDist, 1);
                        this.draggedTile.scale = 1 + (sizeProgress * 0.3);
                    } else if (released && this.draggedTile) {
                        const tile = this.draggedTile;
                        const originalTile = this.draggedTileOriginal;
                        let swapped = false;

                        //try board-to-board swap with nearest adjacent tile
                        const directions = [{
                                dc: -1,
                                dr: 0
                            },
                            {
                                dc: 1,
                                dr: 0
                            },
                            {
                                dc: 0,
                                dr: -1
                            },
                            {
                                dc: 0,
                                dr: 1
                            }
                        ];

                        for (const dir of directions) {
                            const targetCol = tile.col + dir.dc;
                            const targetRow = tile.row + dir.dr;

                            if (targetCol >= 0 && targetCol < this.cols &&
                                targetRow >= 0 && targetRow < this.rows) {
                                const targetTile = this.tiles[targetRow][targetCol];
                                if (targetTile) {
                                    const dist = Math.hypot(
                                        tile.x - targetTile.x,
                                        tile.y - targetTile.y
                                    );
                                    if (dist < this.tileSize * 0.6) {
                                        this.swapTiles(tile, targetTile);
                                        this.pendingUserSwap = {
                                            tile1: tile,
                                            tile2: targetTile
                                        };
                                        swapped = true;
                                        break;
                                    }
                                }
                            }
                        }

                        //if no swap, animate back to original board position
                        if (!swapped) {
                            tile.targetX = originalTile.x;
                            tile.targetY = originalTile.y;
                            tile.isMoving = true;
                        }

                        if (this.draggedTile) this.draggedTile.beingDragged = false;
                        if (this.draggedTile) this.draggedTile.scale = 1;
                        this.draggedTile = null;
                        this.draggedTileOriginal = null;
                    }
                }
            }

            /**
             * GridController: right-side placement grid that accepts tiles from the pool
             * but enforces placement rules (starting tile, side-indicator alignment).
             */
            class GridController {
                /**
                 * Create a GridController.
                 * @param {number} x - Left edge of the grid in canvas/world coordinates.
                 * @param {number} y - Top edge of the grid in canvas/world coordinates.
                 * @param {number} displayW - Total pixel width of the grid display area.
                 * @param {number} displayH - Total pixel height of the grid display area.
                 * @param {number} cellSize - Width and height of each individual cell in pixels.
                 */
                constructor(x, y, displayW, displayH, cellSize) {
                    this.x = x;
                    this.y = y;
                    this.dw = displayW;
                    this.dh = displayH;
                    this.panX = -this.dw / 2 + cellSize / 2;
                    this.panY = -this.dh / 2 + cellSize / 2;
                    this.cellSize = cellSize;
                    this.tiles = [];
                    /*
                    //tile dragging in grid 
                    this.draggedTile = null;
                    this.draggedOrigCol = null;
                    this.draggedOrigRow = null;
                    this.dragOffsetX = 0;
                    this.dragOffsetY = 0;

                    //alogirthm check for swapping
                    this.invalidSwap = false;
                    this.invalidSwapTimer = 0;*/

                    const startCol = 0;
                    const startRow = 0;

                    const startTile = new Tile(startCol, startRow, 0);

                    //got to make sure start tile is compatible lol
                    startTile.sides = {
                        left: true,
                        right: true,
                        up: true,
                        down: true
                    };

                    this.panning = false;

                    // offscreen canvas
                    this.offCanvas = document.createElement("canvas");
                    this.offCanvas.width = this.dw;
                    this.offCanvas.height = this.dh;
                    this.offCtx = this.offCanvas.getContext("2d");

                    //place it without checks
                    this._placeInternal(startTile, startCol, startRow);
                }

                /**
                 * Convert world/canvas coordinates to a grid cell address.
                 * Returns null if the point falls outside the grid's positive cell space.
                 * @param {number} wx - World X coordinate.
                 * @param {number} wy - World Y coordinate.
                 * @returns {{col: number, row: number}|null} The cell under the point, or null.
                 */
                getCellAtPos(wx, wy) {
                    const col = Math.floor((wx - this.x + this.panX) / this.cellSize);
                    const row = Math.floor((wy - this.y + this.panY) / this.cellSize);
                    return {
                        col,
                        row
                    };
                    return null;
                }

                /**
                 * Unconditionally register a tile at the given cell and snap its visual
                 * position to the cell center. Does not validate placement rules.
                 * Use `placeTile` for rule-checked placement from the pool.
                 * @param {Tile} tile - The tile to place.
                 * @param {number} col - Destination column index.
                 * @param {number} row - Destination row index.
                 * @returns {void}
                 */
                _placeInternal(tile, col, row) {
                    this.tiles.push({
                        tile,
                        col,
                        row
                    });
                    tile.inPool = false;
                    tile.inGrid = true;
                    tile.matched = false;
                    tile.opacity = 1;
                    tile.row = row;
                    tile.col = col;
                    const cx = this.x + col * this.cellSize + this.cellSize / 2;
                    const cy = this.y + row * this.cellSize + this.cellSize / 2;
                    tile.targetX = cx;
                    tile.targetY = cy;
                    tile.x = cx;
                    tile.y = cy;
                    tile.isMoving = false;
                    tile.beingDragged = false;
                    tile.scale = 1;

                    //pop particles when a tile lands in the placement grid
                    if (window.App && window.App.placeBurst && tile.inGrid) {
                        window.App.placeBurst.add(
                            this.x - this.panX + col * this.cellSize + this.cellSize / 2,
                            this.y - this.panY + row * this.cellSize + this.cellSize / 2
                        );
                    }
                }

                /**
                 * Attempt to place a tile from the pool into the grid at the given cell,
                 * running side-indicator validation first via `canPlace`.
                 * @param {Tile} tile - The tile to place.
                 * @param {number} col - Target column index.
                 * @param {number} row - Target row index.
                 * @returns {boolean} True if the tile was successfully placed, false if validation failed.
                 */
                placeTile(tile, col, row) {
                    if (!this.canPlace(tile, col, row)) return false;
                    this._placeInternal(tile, col, row);
                    return true;
                }

                /**
                 * Return the tile occupying the given cell, or undefined if the cell is empty.
                 * @param {number} col - Column index to look up.
                 * @param {number} row - Row index to look up.
                 * @returns {Tile|undefined}
                 */
                getTile(col, row) {
                    return this.tiles.find(e => e.col == col && e.row == row)?.tile;
                }

                /**
                 * Validate whether a tile may be placed at the given cell.
                 * Rules enforced:
                 *  - Cell must be within grid bounds.
                 *  - Cell must currently be empty.
                 *  - The tile must have at least one existing neighbor.
                 *  - For every neighbor, the touching sides must either both have indicators or both lack them.
                 * @param {Tile} tile - The tile being considered for placement.
                 * @param {number} col - Target column index.
                 * @param {number} row - Target row index.
                 * @returns {boolean} True if placement is legal, false otherwise.
                 */
                canPlace(tile, col, row) {
                    if (this.getTile(col, row)) return false;

                    const neighbors = [
                        {
                            dc: -1,
                            dr: 0,
                            mySide: 'left',
                            theirSide: 'right'
                        },
                        {
                            dc: 1,
                            dr: 0,
                            mySide: 'right',
                            theirSide: 'left'
                        },
                        {
                            dc: 0,
                            dr: -1,
                            mySide: 'up',
                            theirSide: 'down'
                        },
                        {
                            dc: 0,
                            dr: 1,
                            mySide: 'down',
                            theirSide: 'up'
                        }
                    ];

                    let numNeighbors = 0;
                    for (const n of neighbors) {
                        const nc = col + n.dc;
                        const nr = row + n.dr;
                        const neighbor = this.getTile(nc, nr);
                        if (!neighbor) continue;
                        numNeighbors++;
                        if (
                            (tile.sides?.[n.mySide] && neighbor.sides?.[n.theirSide]) ||
                            (!tile.sides?.[n.mySide] && !neighbor.sides?.[n.theirSide])
                        ) {
                            continue;
                        }
                        return false;
                    }

                    return numNeighbors > 0;
                }

                /**
                 * Remove the tile entry at the given cell from the internal tiles array.
                 * Does not animate or return the tile  callers are responsible for
                 * re-placing or discarding the tile object afterward.
                 * @param {number} col - Column of the tile to remove.
                 * @param {number} row - Row of the tile to remove.
                 * @returns {void}
                 */
                remove(col, row) {/*
                    const idx = this.tiles.findIndex(e => e.col === col && e.row === row);
                    if (idx >= 0) this.tiles.splice(idx, 1);*/
                }

                /**
                 * ARROW. Can you please expain why this exists?
                 * I thought the tiles on the grid were permanent.
                 * 
                 * Process pointer input each frame to support dragging tiles within the grid.
                 * On press: lifts the tile under the pointer out of the grid.
                 * On hold: follows the pointer.
                 * On release: attempts to place the tile in the target cell, running
                 *  anPlace checks for both empty-cell drops and same-cell swaps.
                 *   On failure, the tile snaps back to its origin and triggers the invalid flash.
                 * @returns {void}
                 */
                handleInput() {/*
                    //for simplicity. Don't have to keep finding the mouse object
                    const {
                        screenX,
                        screenY,
                        down,
                        wasDown
                    } = mouse;
                    const clickHappened = down && !wasDown;
                    const released = !down && wasDown;

                    if (clickHappened && !this.draggedTile) {
                        const {
                            x: wx,
                            y: wy
                        } = screenToWorld(screenX, screenY);
                        const cell = this.getCellAtPos(wx, wy);
                        if (cell) {
                            const tile = this.getTile(cell.col, cell.row);
                            if (tile) {
                                //lift tile off the grid
                                this.remove(cell.col, cell.row);
                                this.draggedTile = tile;
                                this.draggedOrigCol = cell.col;
                                this.draggedOrigRow = cell.row;
                                this.dragOffsetX = wx - tile.x;
                                this.dragOffsetY = wy - tile.y;
                                tile.beingDragged = true;
                                tile.scale = 1.2;
                            }
                        }
                    } else if (this.draggedTile && down) {
                        const {
                            x: wx,
                            y: wy
                        } = screenToWorld(screenX, screenY);
                        this.draggedTile.x = wx - this.dragOffsetX;
                        this.draggedTile.y = wy - this.dragOffsetY;

                    } else if (released && this.draggedTile) {
                        const tile = this.draggedTile;
                        tile.beingDragged = false;
                        tile.scale = 1;
                        this.draggedTile = null;

                        const origCol = this.draggedOrigCol;
                        const origRow = this.draggedOrigRow;
                        this.draggedOrigCol = null;
                        this.draggedOrigRow = null;

                        const dropCell = this.getCellAtPos(tile.x, tile.y);
                        let placed = false;

                        if (dropCell) {
                            const existing = this.getTile(dropCell.col, dropCell.row);

                            if (existing) {
                                //temporarily remove existing so canPlace sees clean neighbors
                                this.remove(dropCell.col, dropCell.row);

                                const tileCanGo = this.canPlace(tile, dropCell.col, dropCell.row);
                                const existingCanGo = this.canPlace(existing, origCol, origRow);

                                if (tileCanGo && existingCanGo) {
                                    //valid swap commit both moves
                                    this._placeInternal(existing, origCol, origRow);
                                    this._placeInternal(tile, dropCell.col, dropCell.row);
                                    placed = true;
                                } else {
                                    //invalid swap put existing back in place, then snap tile home
                                    this._placeInternal(existing, dropCell.col, dropCell.row);
                                }
                            } else {
                                //empty cell case validate before placing
                                if (this.canPlace(tile, dropCell.col, dropCell.row)) {
                                    this._placeInternal(tile, dropCell.col, dropCell.row);
                                    placed = true;
                                    if (window.App) window.App.addShake(0.8);
                                }
                            }
                        }

                        if (!placed) {
                            //return tile to its original position and flash an invalid indicator
                            this._placeInternal(tile, origCol, origRow);
                            this.invalidSwap = true;
                            this.invalidSwapTimer = 0;
                        }
                    }*/
                }

                /**
                 * Advance grid animations and decay timed state.
                 * @param {number} dt - Delta time in seconds since the last frame.
                 * @returns {void}
                 */
                update(dt) {
                    for (const entry of this.tiles)
                        if (entry.tile) entry.tile.animate(dt);
                }

                /**
                 * Pan the grid to the last placed tile.
                 * @returns {void}
                 */
                panToLastPlaced() {
                    const { row, col } = this.tiles[this.tiles.length - 1];
                    this.panX = -this.dw / 2 + this.cellSize * (col + 0.5);
                    this.panY = -this.dh / 2 + this.cellSize * (row + 0.5);
                }

                /**
                 * Pan the grid, based on keys.
                 * @returns {void}
                 */
                pan() {
                    const { down, screenX, screenY } = mouse;
                    const { x, y } = screenToWorld(screenX, screenY);
                    if (!this.panning && mouse.down && !mouse.wasDown &&
                        x >= this.x && x <= this.x + this.dw &&
                        y >= this.y && y <= this.y + this.dh
                    ) {
                        this.panning = true;
                        this.panStartX = this.panX + x;
                        this.panStartY = this.panY + y;
                    }
                    if (this.panning && mouse.down) {
                        this.panX = this.panStartX - x;
                        this.panY = this.panStartY - y;
                    }
                    if (this.panning && !mouse.down) {
                        this.panning = false;
                    }
                }

                /**
                 * Render the grid background, cell lines, all placed tiles, the in-flight
                 * dragged tile (drawn last so it appears on top), and the invalid-swap
                 * flash overlay if active.
                 * @returns {void}
                 */
                draw() {
                    // offscreen canvas
                    const octx = this.offCtx;
                    octx.clearRect(0, 0, this.dw, this.dh);
                    octx.fillStyle = "rgba(224, 221,211,255)";
                    octx.fillRect(0, 0, this.dw, this.dh);
                    
                    ctx.save();
                    
                    ctx.save();
                    ctx.setLineDash([]);
                    ctx.strokeStyle = 'rgba(25, 25, 25)';
                    ctx.lineWidth = 8;

                    ctx.beginPath(); 
                    ctx.moveTo(this.x - 4, this.y); 
                    ctx.lineTo(this.x + this.dw + 4, this.y);
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y); 
                    ctx.lineTo(this.x, this.y + this.dh + 4);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    ctx.restore();

                    octx.setLineDash([5, 5]);
                    octx.strokeStyle = 'rgba(18, 18, 18, 0.6)';
                    // a little bit of math to find where to put the first line
                    const startingX = -this.panX + Math.ceil(this.panX / this.cellSize) * this.cellSize;
                    for (let x = startingX; x <= this.dw; x += this.cellSize) {
                        octx.beginPath();
                        octx.moveTo(x, 0);
                        octx.lineTo(x, this.dh);
                        octx.stroke();
                    }
                    const startingY = -this.panY + Math.ceil(this.panY / this.cellSize) * this.cellSize;
                    for (let y = startingY; y <= this.dh; y += this.cellSize) {
                        octx.beginPath();
                        octx.moveTo(0, y);
                        octx.lineTo(this.dw, y);
                        octx.stroke();
                    }
                    for (const entry of this.tiles) {
                        if (entry && entry.tile) {
                            const et = entry.tile;
                            // The .5 is necessary because the draw call draws it relative to center
                            PixelArt.draw(
                                octx,
                                et.colorIndex,
                                et.sides,
                                (entry.col + 0.5) * this.cellSize - this.panX,
                                (entry.row + 0.5) * this.cellSize - this.panY,
                                this.cellSize,
                                et.opacity,
                                et.scale,
                                false
                            );
                        }
                    }
                    octx.setLineDash([]);
                    /*
                    //draw the tile being dragged above everything else
                    if (this.draggedTile) {
                        const drt = this.draggedTile;
                        PixelArt.draw(
                            ctx,
                            drt.colorIndex,
                            drt.sides,
                            drt.x * this.cellSize, drt.y * this.cellSize,
                            this.cellSize,
                            drt.opacity,
                            drt.scale,
                            true
                        );
                    }*/

                    ctx.drawImage(this.offCanvas, this.x, this.y);
                    ctx.restore();
                }
            }

            //layout junk
            const GAP = 4;
            const TS = Math.floor(Math.min(width, height) / 12);
            const BOARD_Y = TS + 32;

            // left board
            const leftBoardCols = 4;
            const leftBoardX = 5;
            const leftBoardRows = Math.floor((height - BOARD_Y) / TS);

            // right board
            const rightBoardX = leftBoardCols * TS + GAP;
            const rightBoardRows = 5;
            const rightBoardCols = Math.floor((width - rightBoardX) / TS);
            const rightBoardY = BOARD_Y;

            // placement grid centered in the space below the right board
            const gridX = leftBoardX + leftBoardCols * TS + GAP;
            const gridY = BOARD_Y + rightBoardRows * TS + GAP;

            this.rightGrid = new GridController(gridX, gridY, rightBoardCols * TS, (leftBoardRows - rightBoardRows) * TS, TS);
            this.tileBoard = new TileBoard(leftBoardCols, leftBoardRows, rightBoardCols, rightBoardRows, leftBoardX, BOARD_Y, TS);

            //trigger a one-time cascade check on the board so seam matches get cleared at startup(?)
            this.tileBoard.swapInProgress = true;

            //shake states
            this.shake = {
                x: 0,
                y: 0
            };
            this.shakes = [];

            //particle systems
            this.matchBurst = new ParticleSystem({
                add: function(x, y, color) {
                    for (let i = 0; i < 8; i++) {
                        const angle = (Math.PI * 2 * i) / 8 + Math.random() * 0.4;
                        const speed = 80 + Math.random() * 120;
                        this.particles.push(particlePool.get({
                            position: {
                                x,
                                y
                            },
                            velocity: {
                                x: Math.cos(angle) * speed / 10,
                                y: Math.sin(angle) * speed / 10
                            },
                            size: 4 + Math.random() * 5,

                            //hex to annoy xyzyyxx
                            color: color || "#45B7D1",
                            life: 80 + Math.random() * 40,
                            acceleration: {
                                x: 0,
                                y: 2
                            },
                            angle: Math.random() * 360,
                            rotation: (Math.random() - 0.5) * 400,
                            clear: true,
                            opacity: 1
                        }));
                    }
                }
            });

            this.placeBurst = new ParticleSystem({
                add: function(x, y) {
                    for (let i = 0; i < 5; i++) {
                        const angle = -Math.PI / 2 + (Math.random() - 0.5) * Math.PI;
                        const speed = 40 + Math.random() * 80;
                        this.particles.push(particlePool.get({
                            position: {
                                x,
                                y
                            },
                            velocity: {
                                x: Math.cos(angle) * speed / 10,
                                y: Math.sin(angle) * speed / 10
                            },
                            size: 3 + Math.random() * 4,
                            color: '#ffe066',
                            life: 50 + Math.random() * 30,
                            acceleration: {
                                x: 0,
                                y: 3
                            },
                            angle: Math.random() * 360,
                            rotation: (Math.random() - 0.5) * 300,
                            clear: true,
                            opacity: 1
                        }));
                    }
                }
            });

            //ref
            window.App = window.App || this;
        };

        /**
         * A partical. I was intially going to make them drawn by an offscreen secondary canvas, however they are to few to make this necessary 
         * 
         * @constructor
         * @param {object} config - configuration settings for the particle
         * @param {object} [config.position={}] - initial x and y coordinates
         * @param {number} [config.size=10] - diameter or side length
         * @param {string} [config.color] - fill color or hex code
         * @param {object} [config.velocity={}] - change in position per second
         * @param {number} [config.life=100] - duration until the particle expires
         * @param {object} [config.acceleration={}] - change in velocity per second
         * @param {number} [config.angle=0] - starting rotation in degrees
         * @param {number} [config.rotation=0] - rotational speed in degrees per second
         * @param {number} [config.opacity=1] - starting transparency level
         * @param {boolean} [config.clear=false] - whether to fade opacity over lifetime
         * @param {boolean} [config.collide=false] - whether physics collisions are enabled
         * @param {CanvasRenderingContext2D} [config.drawingMethod] - the canvas context used for rendering
         */
        function Particle(config) {
            this.position = config.position || Object;
            this.size = config.size || 10;
            this.color = config.color;
            this.velocity = config.velocity || Object;
            this.life = config.life || 100;
            this.acceleration = config.acceleration || Object;
            this.angle = config.angle || 0;
            this.rotation = config.rotation || 0;
            this.opacity = config.opacity || 1;
            this.clear = config.clear || false;
            this.collide = config.collide || false;

            //this.dT = deltaTime;
            this.initialLife = config.life;
            this.drawingMethod = config.drawingMethod || ctx;
        };

        /* Update a particle */
        Particle.prototype.update = function(DT) {
            this.velocity.x += this.acceleration.x * DT;
            this.velocity.y += this.acceleration.y * DT;

            this.position.x += this.velocity.x * DT;
            this.position.y += this.velocity.y * DT;

            this.angle += this.rotation * DT;

            if (this.clear !== false) {
                this.opacity = Math.max(0, this.life / this.initialLife);
            } else {
                this.opacity = 1;
            }

            this.life -= 60 * DT;
        };

        /* Draw a particle */
        Particle.prototype.draw = function() {
            this.drawingMethod.save();
            this.drawingMethod.translate(this.position.x + this.size / 2, this.position.y + this.size / 2);
            this.drawingMethod.rotate(this.angle / 180 * Math.PI);
            this.drawingMethod.fillStyle = this.color;
            this.drawingMethod.globalAlpha = this.opacity;
            this.drawingMethod.fillRect(-this.size / 2, -this.size / 2, this.size, this.size);
            this.drawingMethod.restore();
        };

        /* What happens when a particle dies? */
        Particle.prototype.die = function() {
            return this.life < 0;
        };

        /* Run the particle */
        Particle.prototype.run = function(DT) {
            this.draw();
            this.update(DT);
        };

        /* Shallow copy of the particle for pooling */
        Particle.prototype.deepCopy = function(config) {
            /* 
                @Judges - This is really a shallow copy, lol. But deepCopy sounds cooler. This function copies a particle and resets it for future use. This is sometimes marginally faster or broadly faster than creating a brand new one and delting the old one, it depends on the context
            */
            this.position = {
                x: (config.position && config.position.x) || 0,
                y: (config.position && config.position.y) || 0
            };
            this.size = config.size || 10;
            this.color = config.color || '#fff';
            this.velocity = {
                x: (config.velocity && config.velocity.x) || 0,
                y: (config.velocity && config.velocity.y) || 0
            };
            this.life = (config.life !== undefined ? config.life : 100);
            this.initialLife = this.life;

            this.acceleration = {
                x: (config.acceleration && config.acceleration.x) || 0,
                y: (config.acceleration && config.acceleration.y) || 0
            };
            this.angle = config.angle || 0;
            this.rotation = config.rotation || 0;
            this.opacity = (config.opacity !== undefined ? config.opacity : 1);
            this.clear = !!config.clear;
            this.collide = !!config.collide;
            this._pooledActive = true;
        };

        /**
         * manages a collection of reusable particle instances to minimize garbage collection
         * 
         * @param {number} [initialSize=400] - number of particles to preallocate in memory
         */
        class ParticlePool {
            /* @Judges - The magic of a particle pool! */
            constructor(initialSize = 400) {
                this.pool = [];
                for (let i = 0; i < initialSize; i++) {
                    //create a minimal particle instance
                    const p = new Particle({
                        position: {
                            x: 0,
                            y: 0
                        },
                        velocity: {
                            x: 0,
                            y: 0
                        },
                        size: 1,
                        color: '#000',
                        life: 0,
                        acceleration: {
                            x: 0,
                            y: 0
                        }
                    });
                    p._pooledActive = false;
                    this.pool.push(p);
                }
            }

            //acquire a particle and initialize it with config
            get(config) {
                const p = this.pool.length ? this.pool.pop() : new Particle({
                    position: {
                        x: 0,
                        y: 0
                    },
                    velocity: {
                        x: 0,
                        y: 0
                    },
                    size: 1,
                    color: '#000',
                    life: 0,
                    acceleration: {
                        x: 0,
                        y: 0
                    }
                });
                p.deepCopy(config);
                return p;
            }

            //release a particle back to the pool
            release(p) {
                //minimal reset to avoid keeping large nested references
                p._pooledActive = false;
                p.life = 0;
                //zero velocities so reused state is clean
                if (p.position) {
                    p.position.x = 0;
                    p.position.y = 0;
                }
                if (p.velocity) {
                    p.velocity.x = 0;
                    p.velocity.y = 0;
                }
                //push back into pool (no capacity limit here)
                this.pool.push(p);
            }
        }
        const particlePool = new ParticlePool(400);

        /**
         * coordinates the creation, updating, and pooled recycling of multiple particles
         * 
         * @param {object} config - system configuration settings
         * @param {function} [config.add] - function defined to handle particle creation logic
         */
        function ParticleSystem(config) {
            this.add = config.add || function() {};
            //particles that clear when a level loads
            this.particles = [];

            //paricles that don't clear
            this.foreverParticles = [];

        };

        /* Add a particle */
        ParticleSystem.prototype.addParticle = function() {
            this.add();
        };
        ParticleSystem.prototype.col = function() {};

        /* Run a particle system. Fetch from pool, etc */
        ParticleSystem.prototype.run = function(DT) {
            //scrap object if particles not being added
            if (!this.add) {
                this.addParticle();
            }

            //update normal particles (swap-pop removal)
            for (let i = this.particles.length - 1; i >= 0; i--) {
                const p = this.particles[i];
                p.run(DT);
                if (p.die()) {
                    //release to pool
                    particlePool.release(p);
                    //remove in O(1) by replacing with last element
                    const last = this.particles.pop();
                    if (i < this.particles.length) {
                        this.particles[i] = last;
                    }
                }
            }

            //update foreverParticles (same pattern)
            for (let i = this.foreverParticles.length - 1; i >= 0; i--) {
                const p = this.foreverParticles[i];
                p.run(DT);

                if (p.collide) {
                    //
                }
                if (p.die()) {
                    particlePool.release(p);
                    const last = this.foreverParticles.pop();
                    if (i < this.foreverParticles.length) {
                        this.foreverParticles[i] = last;
                    }
                }
            }

        };

        /**
         * creates a screen shake effect that diminishes over time
         * 
         * @param {number} n - the initial intensity or power of the shake
         * @param {object} app - the application state
         */
        function Shake(n, app) {
            this.app = app;
            //shake power
            this.n = n;
        };
        Shake.prototype.active = function(increment) {
            /* @Judges - Note the turret bullets on impact produce a subtle screen shake */
            //apply shake
            this.app.shake.x = (Math.random() * 2 - 1) * this.n;
            this.app.shake.y = (Math.random() * 2 - 1) * this.n;

            //fade the shake
            this.n -= 0.5;

            if (this.n < 0) {
                this.app.shake.x = 0;
                this.app.shake.y = 0;
                this.app.shakes.splice(increment, 1);
            }
        };

        /**
         * adds a subtle screen shake using the existing Shake system
         * @param {number} [power=1] - shake strength in pixels
         */
        App.prototype.addShake = function(power = 1) {
            /* @Judges - This consolidates the shake constructor into a reusable function. It uses some fun syntax as well! */
            power = Number(power);
            if (!isFinite(power) || power <= 0) return;
            if (!this.shakes) this.shakes = [];

            //merge into last shake to avoid spam
            const last = this.shakes.length ? this.shakes[this.shakes.length - 1] : null;
            if (last && typeof last.n === "number") {
                last.n = Math.max(last.n, power);
                return;
            }
            //cap shake list length
            if (this.shakes.length > 6) {
                this.shakes.length = 6;
            }
            this.shakes.push(new Shake(power, this));
        };

        /* Run the game */
        App.prototype.runGame = function(dt) {
            ctx.fillStyle = "rgb(250, 250, 225)";
            ctx.fillRect(0, 0, width, height);

            //update shakes
            for (let i = this.shakes.length - 1; i >= 0; i--) {
                this.shakes[i].active(i);
            }

            //apply shake offset
            ctx.save();
            ctx.translate(Math.round(this.shake.x), Math.round(this.shake.y));

            const b = this.tileBoard;
            if (b) {
                b.update(dt);
                b.pool.update(dt);
                b.handleInput();
                b.pool.handleInput();
                b.draw();
            }
            if (this.rightGrid) {
                this.rightGrid.update(dt);
                this.rightGrid.pan();
                this.rightGrid.draw();
            }

            // single unified border around everything
            const b2 = this.tileBoard;
            if (b2 && this.rightGrid) {
                ctx.save();
                ctx.strokeStyle = 'rgba(25, 25, 25)';
                ctx.lineWidth = 4;
                ctx.strokeRect(
                    b2.boardX - 5,
                    b2.boardY - 5,
                    (b2.cols1 + b2.cols2) * b2.tileSize + 10,
                    b2.rows1 * b2.tileSize + 10
                );
                ctx.restore();
            }
            //run particles (drawn on top, inside shake offset so they follow the camera)
            this.matchBurst.run(dt);
            this.placeBurst.run(dt);

            ctx.restore();
        };

        /* Run the scenes */
        App.prototype.scenes = function(DT) {
            switch (window.scene) {
                case "intro": {
                    //only run intro in main window, not fullscreen popup
                    if (!window.opener) {
                        intro.run();

                        //when intro finishes, transition to menu
                        if (intro.prog > 360) {
                            window.scene = "menu";
                        }
                    } else {
                        //in popup/fullscreen, skip intro
                        window.scene = "menu";
                    }
                    break;
                }
                case "menu": {
                    ctx.fillStyle = "rgb(5, 5, 25)";
                    ctx.fillRect(0, 0, width, height);
                    break;
                }
                case "load": {
                    if (!cache.loaded) {
                        cache.load();
                        ctx.fillStyle = "rgb(255, 255, 255)";
                        ctx.fillRect(0, 0, width, height);
                        ctx.font = "25px Arial";
                        ctx.fillStyle = "rgb(35, 35, 35)";
                        ctx.fillText("Loading", 300, 300);
                    } else {
                        window.scene = "game";
                    }
                    break;
                }
                case "game": {
                    this.runGame(DT);
                    break;
                }
                case "win": {
                    ctx.fillStyle = "rgb(5, 5, 25)";
                    ctx.fillRect(0, 0, width, height);

                    ctx.save();
                    ctx.fillStyle = "rgb(255, 215, 0)";
                    ctx.font = "bold 72px Comfortaa";
                    ctx.textAlign = "center";
                    ctx.fillText("VICTORY!", width / 2, height / 2 - 80);

                    ctx.fillStyle = "rgb(245, 245, 245)";
                    ctx.font = "bold 36px Lato";

                    //
                    if (!this.winScoreEncoded) {
                        this.finalScore = Math.ceil(this.score);
                        this.encodedScore = btoa(Z.encode(this.finalScore));
                        textToCopy = this.encodedScore;
                        this.winScoreEncoded = true;
                    }

                    ctx.fillText("Final Score: " + this.finalScore, width / 2, height / 2);

                    ctx.font = "24px Lato";
                    ctx.fillText("Encoded: " + this.encodedScore, width / 2, height / 2 + 50);

                    ctx.font = "20px Lato";
                    ctx.globalAlpha = 0.7;
                    ctx.fillText("Click 'Copy Score' to copy your encoded score!", width / 2, height / 2 + 90);

                    // ctx.globalAlpha = 1;
                    // ctx.font = "24px Lato";
                    // ctx.fillText("Press SPACE to play again", width / 2, height / 2 + 130);
                    // ctx.restore();

                    //show copy button
                    document.getElementById('copyButton').style.display = "block";

                    if (keys[32]) {
                        document.getElementById('copyButton').style.display = "none";
                        this.winScoreEncoded = false;
                        this.resetGame();
                        window.scene = "game";
                    }
                    break;
                }
                case "death": {
                    ctx.fillStyle = "rgb(25, 5, 5)";
                    ctx.fillRect(0, 0, width, height);

                    ctx.save();
                    ctx.fillStyle = "rgb(255, 80, 80)";
                    ctx.font = "bold 72px Comfortaa";
                    ctx.textAlign = "center";
                    ctx.fillText("DEFEAT", width / 2, height / 2 - 80);

                    ctx.fillStyle = "rgb(245, 245, 245)";
                    ctx.font = "bold 36px Lato";
                    ctx.fillText("Score: " + Math.ceil(this.score), width / 2, height / 2);

                    ctx.font = "24px Lato";
                    ctx.globalAlpha = 0.7;
                    ctx.fillText("You ran out of health!", width / 2, height / 2 + 50);

                    ctx.globalAlpha = 1;
                    ctx.font = "24px Lato";
                    ctx.fillText("Press SPACE to try again", width / 2, height / 2 + 100);
                    ctx.restore();

                    if (keys[32]) {
                        //clear both flags
                        try {
                            const rawSave = storage.getItem("dronemaker_save_v1");
                            if (rawSave) {
                                const save = JSON.parse(rawSave);
                                save.isDead = false;
                                save.playerHp = 10;
                                storage.setItem("dronemaker_save_v1", JSON.stringify(save));
                            }
                        } catch (e) {}

                        this.player.die = false;
                        this.resetGame();
                        window.scene = "game";
                    }
                    break;
                }
            }
        };

        /* Run the application */
        App.prototype.run = function(DT) {
            this.scenes(DT);
        };

        return App;
    })();

    //intiate a new game
    window.App = new Application({});

    //start a lightweight drawer for pool andd tilemap so they render on top
    (function startTileDraw() {
        /**
         * Background drawer used to render auxiliary layers (tile pool / tile map)
         * above the main loop. Runs on its own RAF.
         */
        function loop() {
            requestAnimationFrame(loop);
        }
        //requestAnimationFrame(loop);
    })();


    console.createGraph("fps: low buffer", () => fps, {
        width: 240,
        height: 48,
        //note to self, this only should take in hex codes
        color: "#9ad0ff",

        buffer: 60,
        min: 0,
        max: 120,
    });


    //a render loop with a timestamp for dt updating @Judges
    /**
     * Main render function invoked by the RAF-driven loop. Updates timing values,
     * clears the canvas and runs the application `App.run` with computed delta time.
     * @param {DOMHighResTimeStamp|number} timestamp
     * @returns {void}
     */

    const render = (timestamp) => {
        try {
            //prefer the rAF timestamp when present
            const now = typeof timestamp === "number" ? timestamp : performance.now();

            //dt in milliseconds, never negative
            dtMs = Math.max(0, now - lastTime);
            lastTime = now;

            //dt in seconds (clamped to avoid huge jumps after tab hidden)
            dt = Math.min(dtMs / 1000, 0.1);
            fps = dtMs > 0 ? Math.round(1000 / dtMs) : fps;

            //console.log("deltaTime", dt);

            ctx.setTransform(dprVal, 0, 0, dprVal, 0, 0);
            ctx.clearRect(0, 0, canvas.width / dprVal, canvas.height / dprVal);
            //run the game based on deltatime
            App.run(dt);

            //@Judges DT makes this run smoothly on any device with any framerate

            //reset events
            mouse.released = false;
            mouse.clicked = false;

            const button2 = document.getElementById("reload");

            // //clear local storage
            // const clearLocal = () => {
            //     storage.clear();
            //     //alert(JSON.stringify(storage))
            // };

            button2.addEventListener("click", () => {
                if (App && typeof App.resetGame === 'function') {
                    //App.resetGame();
                }
            });

            //frameCount
            frameCount++;

            // Was mouse down
            mouse.wasDown = mouse.down;
        } catch (e) {
            console.error("Main loop error\n" + e.stack);
        }
    };

    //Replace interval with rAF
    let rafId = null;
    let running = true;

    //pause when tab hidden to avoid wasted frames @Judges
    document.addEventListener("visibilitychange", () => {
        running = !document.hidden;
        if (running && rafId === null) {
            rafId = requestAnimationFrame(loop);
        }
        if (!running && rafId !== null) {
            cancelAnimationFrame(rafId);
            rafId = null;
        }
    });
    /**
     * main animation loop that requests frames and triggers rendering while the game is running
     * @param {number} now - the current timestamp provided by requestanimationframe
     * @returns {void}
     */
    /**
     * High level loop that guards running state and schedules the next RAF.
     * @param {number} now - The current timestamp from requestAnimationFrame.
     * @returns {void}
     */
    function loop(now) {
        //if (!debug.freeze) {
        if (!running) {
            rafId = null;
            return;
        }
        render(now);
        rafId = requestAnimationFrame(loop);
        //}
        //console.info(debug.freeze);
    }

    //start
    if (rafId) cancelAnimationFrame(rafId);
    rafId = requestAnimationFrame(loop);

    // if (loopTimer) window.clearInterval(loopTimer);
    // var loopTimer = window.setInterval(render, 1000/60);

    window.addEventListener("keydown", (e) => {
        if (e.which === 192) {
            showThumb();
        }
        e.preventDefault();
        keys[e.which] = true;
    });
    window.addEventListener("keyup", (e) => {
        if (e.which === 192) {
            hideThumb();
        }
        e.preventDefault();
        keys[e.which] = false;
    });

    //add mouse events
    window.addEventListener("click", (e) => {
        //e.preventDefault();
        mouse.clicked = true;
    });
    window.addEventListener("mouseup", (e) => {
        //e.preventDefault();
        mouse.released = true;
        mouse.down = false;
    });
    window.addEventListener("mousedown", (e) => {
        //e.preventDefault();
        mouse.down = true;
    });
    window.addEventListener("mousedown", (e) => {
        if (e.button === 2) {
            mouse.rightDown = true;
            mouse.rightReleased = false;
        } else if (e.button === 0) {
            mouse.down = true;
            mouse.released = false;
        }
    });

    window.addEventListener("mouseup", (e) => {
        if (e.button === 2) {
            mouse.rightDown = false;
            mouse.rightReleased = true;
        } else if (e.button === 0) {
            mouse.down = false;
            mouse.released = true;
        }
    });
    window.addEventListener("contextmenu", (e) => {
        //disableContextMenu to allow for right clicks in game
        //e.preventDefault();
    });

    //prevents focus spam
    window.addEventListener("blur", () => {
        mouse.down = false;
        mouse.rightDown = false;
    });
    //store mouse in world coordinates
    window.addEventListener("mousemove", (e) => {
        mouse.screenX = e.clientX;
        mouse.screenY = e.clientY;

        //convert screen to world CORRECTLY
        const worldPos = screenToWorld(e.clientX, e.clientY);
        mouse.x = worldPos.x;
        mouse.y = worldPos.y;
    });

    /**
     * converts world coordinates to screen coordinates by applying camera translation and scale
     * @param {number} worldx - the horizontal position in the game world
     * @param {number} worldy - the vertical position in the game world
     * @returns {object} an object containing the calculated x and y screen coordinates
     */
    function worldToScreen(worldX, worldY) {
        const totalScale = App.cam.z * displayScale;

        //apply camera translation
        const camX = worldX - App.cam.x + App.cam.align.x - (App.shake.x || 0);
        const camY = worldY - App.cam.y + App.cam.align.y - (App.shake.y || 0);

        //then apply scaling
        const screenX = camX * totalScale;
        const screenY = camY * totalScale;

        return {
            x: screenX,
            y: screenY
        };
    }

    //get fullscreen icon
    const button = document.getElementById("fullscreen");

    //Event
    window.addEventListener("resize", function() {
        if (typeof minimap !== "undefined" && minimap.init) minimap.init();
    });

    // Back to last placed tile
    document.querySelector("#back").addEventListener("click", e => {
        window.App.rightGrid.panToLastPlaced();
    });

    //intiate...
    /**
     * Open the current document in a new window (simple fullscreen mode). Copies
     * the current DOM HTML into the new window and sets a session flag to skip the menu.
     * @returns {void}
     */
    const openInFullscreen = () => {
        sessionStorage.setItem('skipMenu', 'true');

        const w = window.open();
        w.document.open();
        w.document.write(
            `<!doctype html><html>${document.querySelector("html").innerHTML}</html>`,
        );
        w.document.close();
    };

    //add the event listener
    button.addEventListener("click", openInFullscreen);


    firstFrame = false;

    return {
        Application,
        render,
    };
})();

//document.getElementById("thumb").style.display = "none";
document.getElementById("game").style.border = "none";
    </script>
</html> 










