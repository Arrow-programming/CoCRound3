<!DOCTYPE html>
<html> 
    <head>
        <!--Encoding and viewport-->
	    <meta charset="utf-8">
	    <meta name="viewport" content="width=device-width, initial-scale=1">
        <!--Import google fonts, preconnecting allows fonts to be loaded by the canvas. This is very important! It allows me to easily add text without a hacky promise method -->
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Bangers&family=Exo">
        <!--For the thumb title-->
        <link href="https://fonts.googleapis.com/css2?family=Comfortaa:wght@300..700" rel="stylesheet">
        <link rel='stylesheet' href='https://fonts.googleapis.com/css2?family=Lato&family=Material+Icons&display=swap'>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/Arrow-programming/base64/matchMusic.js"></script>
        <!--The page title-->
        <title>New Webpage ;)</title>
        <!--CSS Styling-->
        <style>
            body {
                width: 100vw;
                height: 100vh;
                margin: 0;
                padding: 0;
                overflow: hidden;
                align-items: center;
                transition: 0s;
                background-color: #f0f0f0;
            }
            a {
                display: inline-block;
                position: relative;
                color: rgb(255, 255, 255);
                text-decoration: none;
            }

            a::before {
                content: "";
                position: absolute;
                width: 100%;
                height: 2px;
                bottom: 0;
                left: 0;
                background-color: rgb(255, 255, 255);
                visibility: hidden;
                transform: scaleX(0);
                transition: all 0.3s ease-in-out 0s;
            }

            a:hover::before {
                visibility: visible;
                transform: scaleX(1);
            }

            canvas {
                /*disable anti-aliasing*/
                image-rendering: pixelated;
                transition: none !important;
            }

            canvas:focus {
                outline: none;
            }

            #container {
                color: black;
                display: flex;
                justify-content: center;
                left: 0%;
            }

            #container canvas, #overlay {
                user-select: none;
            }

            #game-wrapper {
                background: white;
                box-shadow: 0 0 0 2px #333;
            }

            #game {
                display: block;
                border: 2px solid #333;
            }

            /* ChatGPT helped me figure out alignment stuff */
            #fullscreen-container {
                width: 170px;
                border-radius: 8px;
                z-index: 99;
                background: rgb(45, 45, 45);
                border: 1px solid rgb(245, 245, 245);
            }

            #overlay {
                position: fixed;
                top: 0;
                right: 50px;
            }

            #fullscreen-container span {
                position: relative;
                color: rgb(245, 245, 245);
                font-size: 28px;
                border-radius: 100%;
                box-sizing: border-box;
                cursor: pointer;
                transition: background 200ms;
            }
            #fullscreen-container span:hover {
                color: rgb(74, 65, 179);
            }

            #fullscreen {
                left: 40px;
            }

            #audio {
                left: 70px;
            }

            #reload {
                left: 100px;
            }

            #back {
                left: 130px;
            }

            #save {
                left: 160px;
            }

            #endturn {
                left: 190px;
            }

            #copyButton {
                top: 78%;
                left: 50%;
                transform: translate(-50%, 0);
                border: none;
                padding: 6px 15px;
                background-color: rgb(70, 150, 90);
                border-radius: 40px;
                font-size: 20px;
                font-family: "Lato";
                z-index: 10;
                color: white;
                display: none;
            }
            #copyButton:hover {
                background-color: rgb(98, 140, 101);
            }


            #console {
                color: white;
                margin: 5px;
                width: 50%;
                background-color: rgba(25, 25, 25, 0.6);
                font-family: monospace;
                box-sizing: border-box;
                padding: 6px;
                max-height: 220px;
                overflow: auto;
            } 
            #console pre { 
                margin: 0; 
                white-space: pre-wrap; 
            }
            #console .line { 
                color: #ddd; 
            }
            #console .error { 
                color: #ff4d4d; 
                font-weight: 700; 
            }
            #console .warn  { 
                color: #ffb86b; 
            }
            #console .info  { 
                color: #9ad0ff; 
            }

            .material-icons {
                font-size: 25px;
                color: inherit;
                vertical-align: middle;
                margin-left: -40px;
                padding-right: 5px;
            }


            #interface {
                position: absolute;
                width: 100%;
                height: 100%;
                font-family: "Lato";
                user-select: none;
            }

            #tutorial-card {
                background: rgb(233, 233, 233);
                border: 4px solid rgb(25, 25, 25);
                padding: 28px 36px 28px;
                max-width: 500px;
                width: 92vw;
                box-shadow: 6px 6px 0px rgb(25, 25, 25);
                font-family: 'Bangers', sans-serif;
            }

            #tutorial-title {
                font-family: 'Bangers', sans-serif;
                font-size: 32px;
                letter-spacing: 4px;
                text-align: center;
                margin: 0 0 20px 0;
                color: rgb(17, 17, 17);
            }

            #tutorial-steps {
                display: flex;
                flex-direction: column;
                gap: 10px;
            }

            .tut-step {
                display: flex;
                align-items: flex-start;
                gap: 14px;
            }

            .tut-num {
                font-family: 'Bangers', sans-serif;
                font-size: 48px;
                color: rgb(17, 17, 17);
                line-height: 1;
                min-width: 36px;
                text-align: center;
                margin-top: 2px;
            }

            .tut-step p {
                font-family: 'Bangers', sans-serif;
                font-size: 22px;
                letter-spacing: 1px;
                color: rgb(17, 17, 17);
                margin: 0;
                line-height: 1.4;
            }

            .tut-step p .hl {
                background: rgb(67, 163, 88);
                color: white;
                padding: 0 5px;
                border-radius: 3px;
            }

            #tutorial-close {
                display: block;
                margin: 24px auto 0;
                padding: 10px 38px;
                font-family: 'Bangers', sans-serif;
                font-size: 22px;
                letter-spacing: 2px;
                background: rgb(67, 163, 88);
                color: white;
                border: none;
                border-radius: 8px;
                cursor: pointer;
                transition: transform 0.1s, box-shadow 0.1s;
                box-shadow: 3px 3px 0px rgba(0,0,0,0.5);
            }
            #tutorial-close:hover {
                transform: translate(-1px, -1px);
                box-shadow: 4px 4px 0px rgba(0,0,0,0.6);
            }
            #tutorial-close:active {
                transform: translate(1px, 1px);
                box-shadow: 1px 1px 0px rgba(0,0,0,0.4);
            }
            #tutorial-overlay {
                position: fixed;
                inset: 0;
                background: rgba(18, 14, 10, 0.85);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 9999;
                transition: opacity 0.35s ease;
            }
            #tutorial-overlay.hidden {
                opacity: 0;
                pointer-events: none;
            }
        </style>
    </head> 
    <body>
        <div id="tutorial-overlay" class="hidden">
            <div id="tutorial-card">
                <h2 id="tutorial-title">HOW TO PLAY</h2>
                <div id="tutorial-steps">
                    <div class="tut-step">
                        <div class="tut-num">1</div>
                        <p>Match <span class="hl">THREE TILES</span> of the same color to add them to your pool</p>
                    </div>
                    <div class="tut-step">
                        <div class="tut-num">2</div>
                        <p>Match <span class="hl">FOUR TILES</span> to create a <span class="hl">BOMB</span></p>
                    </div>
                    <div class="tut-step">
                        <div class="tut-num">3</div>
                        <p>Drag tiles from the <span class="hl">POOL</span> into the placement grid</p>
                    </div>
                    <div class="tut-step">
                        <div class="tut-num">4</div>
                        <p>Tiles score based on <span class="hl">NEIGHBORS</span> of the same color above and below</p>
                    </div>
                </div>
                <button id="tutorial-close">LET'S PLAY!</button>
            </div>
        </div>
        <!--The container for the entire thing-->
        <div id="container">
            <div id="game-wrapper">
                <canvas id="game">Your browser does not support canvas</canvas>
            </div>
        </div>
        <div id="overlay">
            <button id="copyButton">Copy Score</button>
            <div id="fullscreen-container">
                <span class='material-icons' id='fullscreen'>fullscreen</span>
                <span class='material-icons' id='audio'>volume_up</span>
                <span class='material-icons' id='reload'>refresh</span>
                <span class='material-icons' id='back'>arrow_back</span>
                <span class='material-icons' id='save'>save</span>
                <span class='material-icons' id='endturn'>check</span>
            </div>
        </div>
        <!--All the stinkn' UI-->
        <div id="interface">
            <!--<div id = "score"></div>
            <div id="best-score">Best: 0</div>-->
            <div id="shop" class="hidden">
                <!--toggle, why don't inline functions work anymore?-->
                <div id="shop-tab">
                    <i class="material-icons" style = "margin-right: -45px">shopping_cart</i>
                </div>
    
            </div>
        </div>
        <canvas id = "thumb"></canvas>
    </body>
    
    <script type>
        /* 
            Setup HTML Canvas. Scale Canvas. Frames. Console.
        */
        /**
         * Initializes the main game canvas, overlay canvas, rendering context, display scaling,
         * basic timing variables and a developer console. Returns an object exposing these
         * values for use by the rest of the application.
         * @returns {{canvas: HTMLCanvasElement, ctx: CanvasRenderingContext2D, overlayCanvas: HTMLCanvasElement, octx: CanvasRenderingContext2D, width:number, height:number, dprVal:number, displayScale:number, frameCount:number, firstFrame:boolean, lastTime:number, dtMs:number, dt:number, fps:number, cam:Object, console:Log, shampoedNoodlesAndBacon:string, windowResized:boolean}}
         */
        let { shampoedNoodlesAndBacon, canvas, ctx, width, height, dprVal, displayScale, frameCount, firstFrame, lastTime, dtMs, dt, fps, cam, console, overlayCanvas, octx, windowResized } = (function setUp() {
            //configure HTML5 Canvas
            const theCanvas = document.getElementById("game");
            //https://html.spec.whatwg.org/multipage/canvas.html#concept-canvas-will-read-frequently. Default is falsy
            const canvasContext = theCanvas.getContext("2d", {
                willReadFrequently: false,
            }); 

            let dprVal = window.devicePixelRatio || 1;

            canvasContext.setTransform(dprVal, 0, 0, dprVal, 0, 0);
            
            canvasContext.imageSmoothingEnabled = false;
            canvasContext.webkitImageSmoothingEnabled = false;
            canvasContext.mozImageSmoothingEnabled = false;
            canvasContext.msImageSmoothingEnabled = false;
            canvasContext.oImageSmoothingEnabled = false;
            
            //what this was made on
            const BASE_WIDTH = 600;
            const BASE_HEIGHT = 600;

            //scaling
            let displayScale = 1;
            let width = window.innerWidth;
            let height = window.innerHeight;

            //frame manipulation
            let frameCount = 0;
            let firstFrame = true;
            let lastTime = performance.now();
            let dtMs = 0;
            let dt = 0;
            let fps = 0;
            
            let windowResized = false;

            //the camera with desctructor preventative
            let cam = { 
                x: 0, 
                y: 0
            };

            //garbage collect
            for (let i = window.requestAnimationFrame(() => {}); i > 0; i--) {
                //noodles dipped in shampoo
                window.cancelAnimationFrame(i);
            }

            /**
             * resizes the canvas to match the window dimensions and scales it based on the device pixel ratio (DPR).
             * adjusts the internal coordinate system to maintain sharpness on high-DPI displays and
             * updates the global display scale based on a predefined base resolution (BASE_WIDTH, BASE_HEIGHT)
             *
             * @function
             * @returns {void}
             */
            /**
             * Resize the canvas elements to match the window and scale according to devicePixelRatio.
             * Updates global `width`, `height`, `displayScale`, and canvas internal sizes.
             * @returns {void}
             */
            function resizeCanvasAndScale() {
                /* 
                    @Judges - This function is used to scale the canvas up to a specified dimension. Making it based on the height of the page only allows me to set it at a perfecct 1:1 aspect ratio. The reason this is so fast is because it scales it up with window.devicePixelRation and uses the built in canvas functions for transformations (setTransform) 
                */
                const cssW = window.innerWidth;
                const cssH = window.innerHeight;
                dprVal = window.devicePixelRatio || 1;
            
                //calculate the size that maintains aspect ratio
                const aspectRatio = BASE_WIDTH / BASE_HEIGHT;
                let canvasDisplayWidth, canvasDisplayHeight;
                
                if (cssW / cssH > aspectRatio) {
                    canvasDisplayHeight = cssH;
                    canvasDisplayWidth = cssH * aspectRatio;
                } 
                else {
                    //window is taller than canvas aspect ratio
                    canvasDisplayWidth = cssW;
                    canvasDisplayHeight = cssW / aspectRatio;
                }
            
                //update wrapper size and position
                const wrapper = document.getElementById('game-wrapper');
                if (wrapper) {
                    wrapper.style.width = canvasDisplayWidth + 'px';
                    wrapper.style.height = canvasDisplayHeight + 'px';
                }
            
                theCanvas.style.width = canvasDisplayWidth + "px";
                theCanvas.style.height = canvasDisplayHeight + "px";
                theCanvas.width = Math.round(canvasDisplayWidth * dprVal);
                theCanvas.height = Math.round(canvasDisplayHeight * dprVal);
            
                //update display scale
                displayScale = Math.min(canvasDisplayWidth / BASE_WIDTH, canvasDisplayHeight / BASE_HEIGHT);
            
                width = theCanvas.width / dprVal;
                height = theCanvas.height / dprVal;

                canvasContext.setTransform(dprVal, 0, 0, dprVal, 0, 0);
                canvasContext.imageSmoothingEnabled = false;
                canvasContext.webkitImageSmoothingEnabled = false;
                canvasContext.mozImageSmoothingEnabled = false;
                canvasContext.msImageSmoothingEnabled = false;
                canvasContext.oImageSmoothingEnabled = false;
                
                window.scene = "game";
            }
            window.addEventListener("resize", resizeCanvasAndScale);
            resizeCanvasAndScale();

            //full fledged logger for easy debugging, graphing, and benchmarking. Uses a local canvas
            /**
             * Lightweight DOM-backed logger with optional small graph canvases.
             * Used for debug output and simple numeric graphs.
             */
            class Log {
                /*
            Created by Arrow (December of 2025)
            https://www.khanacademy.org/profile/kaid_5229809678324099512179597/projects
            */
                /**
                 * @param {string} elementId - The DOM id used for the console container element.
                 */
                constructor(elementId) {
                    this.consoleElement = document.getElementById(elementId);

                    //fallback
                    if (!this.consoleElement) {
                        const fallback = document.createElement("div");
                        fallback.id = elementId;
                        fallback.style.border = "1px solid black";
                        fallback.style.padding = "10px";
                        fallback.style.margin = "10px";
                        fallback.style.fontFamily = "monospace";
                        fallback.style.whiteSpace = "pre-wrap";
                        document.body.appendChild(fallback);
                        this.consoleElement = fallback;
                    }

                    this.logs = new Map();
                    this.warnings = new Map();
                    this.errors = new Map();
                    this.infos = new Map();

                    this.baseMessage = "Console:";

                    //store graphs
                    this.graphs = new Map();
                    this._graphAutoFrame = null;

                    //intially render an empty console
                    this.render();
                }

                //stringify values helper
                /**
                 * Safely stringify a value for display in the console.
                 * @private
                 * @param {*} v - Any value to stringify.
                 * @returns {string}
                 */
                _stringify(v) {
                    try {
                        if (typeof v === "object" && v !== null)
                            return JSON.stringify(v, null, 2);
                        return String(v);
                    } catch (err) {
                        return String(v);
                    }
                }

                //log, warning, error, info. Not really the best implementation/copy of the real deal, but I am going for practicallity over functionality
                /**
                 * Store a log entry and re-render the console.
                 * @param {string} key
                 * @param {*} value
                 */
                log(key, value) {
                    if (arguments.length < 2) {
                        return;
                    }
                    this.logs.set(key, this._stringify(value));
                    this.render();
                }
                /**
                 * Store a warning entry.
                 * @param {string} key
                 * @param {*} value
                 */
                warn(key, value) {
                    this.warnings.set(key, this._stringify(value));
                    this.render();
                }
                /**
                 * Store an error entry.
                 * @param {string} key
                 * @param {*} value
                 */
                error(key, value) {
                    this.errors.set(key, this._stringify(value));
                    this.render();
                }
                /**
                 * Store an info entry.
                 * @param {string} key
                 * @param {*} value
                 */
                info(key, value) {
                    this.infos.set(key, this._stringify(value));
                    this.render();
                }

                //render everything to the DOM
                /**
                 * Rebuilds the console DOM content including text and any attached graph canvases.
                 * @returns {void}
                 */
                render() {
                    let outputHTML = `${this.baseMessage}\n`;

                    this.infos.forEach((value, key) => {
                        outputHTML += `<span class="info">INFO: ${key}</span>\n`;
                    });
                    this.errors.forEach((value, key) => {
                        outputHTML += `<span class="error">ERROR: ${key}</span>\n`;
                    });
                    this.warnings.forEach((value, key) => {
                        outputHTML += `<span class="warn">WARNING: ${key}</span>\n`;
                    });
                    this.logs.forEach((value, key) => {
                        outputHTML += `${key}: ${value}\n`;
                    });

                    //preserve graph canvases and re-append after text content to avoid removing them
                    const preserved = [];
                    this.graphs.forEach((g) => {
                        if (g.canvas && g.canvas.parentNode === this.consoleElement) {
                            preserved.push(g.canvas);
                        }
                    });

                    this.consoleElement.innerHTML = `<pre>${outputHTML}</pre>`;

                    for (const c of preserved) {
                        this.consoleElement.appendChild(c);
                    }
                }

                /**
                 * Clears all stored messages and logs the clear action.
                 * @returns {void}
                 */
                clear() {
                    this.info("Console cleared");
                    this.logs.clear();
                    this.warnings.clear();
                    this.errors.clear();
                    this.infos.clear();
                    this.render();
                }

                //yay graphs!
                /**
                 * Create a small graph canvas attached to the console that periodically samples
                 * numeric values from `getter` and plots a rolling history.
                 * @param {string} key - Unique identifier for the graph.
                 * @param {Function|number} getter - Function that returns the current numeric value or a numeric value.
                 * @param {Object} [opts] - Optional graph rendering options.
                 * @returns {HTMLCanvasElement} The created canvas element.
                 */
                createGraph(key, getter, opts = {}) {
                    /**
                     * key: string id
                     * getter: function() numeric value
                     * options: 
                     { 
                        width, height, color, background, buffer, min, max, showValue, strokeWidth, fill
                    }
                    * 
                    */
                    if (!key) {
                        throw new Error("createGraph requires a key");
                    }
                    if (!getter) {
                        throw new Error(
                            "createGraph requires a getter function or numeric value",
                        );
                    }

                    const options = Object.assign(
                        {
                            width: 220,
                            height: 48,
                            color: "#9ad0ff",
                            background: "rgba(0,0,0,0)",
                            buffer: 220,
                            min: null,
                            left: 0,
                            max: null,
                            top: 10,
                            showValue: true,
                            strokeWidth: 2,
                            fill: true,
                        },
                        opts,
                    );

                    //if an existing graph has this same key, remove it
                    if (this.graphs.has(key)) {
                        this.removeGraph(key);
                    }

                    const canvas = document.createElement("canvas");
                    canvas.width = options.width;
                    canvas.height = options.height;
                    canvas.style.display = "block";
                    canvas.style.margin = `${options.top}px ${options.left}px`;
                    canvas.style.background = options.background || "transparent";
                    canvas.style.borderRadius = "4px";
                    canvas.title = key;

                    const ctx = canvas.getContext("2d");

                    const graph = {
                        canvas,
                        ctx,
                        getter,
                        opts: options,
                        history: [],
                    };

                    //append canvas to console
                    this.consoleElement.appendChild(canvas);
                    this.graphs.set(key, graph);

                    if (!this._graphAutoFrame) {
                        this._startGraphAutoUpdate();
                    }

                    return canvas;
                }

                /**
                 * Remove and destroy the graph associated with `key`.
                 * @param {string} key
                 * @returns {void}
                 */
                removeGraph(key) {
                    const entry = this.graphs.get(key);
                    if (!entry) {
                        return;
                    }
                    try {
                        if (entry.canvas && entry.canvas.parentNode) {
                            entry.canvas.parentNode.removeChild(entry.canvas);
                        }
                    } catch {}

                    this.graphs.delete(key);

                    //if no graphs why graph?
                    if (this.graphs.size === 0) {
                        this._stopGraphAutoUpdate();
                    }
                }

                /**
                 * Sample all registered graphs and redraw their canvases. Called by the internal RAF loop.
                 * @returns {void}
                 */
                updateGraphs() {
                    if (!this.graphs || this.graphs.size === 0) {
                        return;
                    }

                    for (const [key, g] of this.graphs) {
                        let value;
                        try {
                            value =
                                typeof g.getter === "function" ? g.getter() : g.getter;
                            //not entirely sure how fast it is to be assigning Number() and isFinite. I might change this into a more agressive approach later
                            value = Number(value);
                            if (!isFinite(value)) {
                                value = 0;
                            }
                        } catch (e) {
                            value = 0;
                        }

                        const hist = g.history;
                        const buffer = Math.max(4, Math.floor(g.opts.buffer));
                        hist.push(value);
                        if (hist.length > buffer) {
                            hist.shift();
                        }

                        const minOpt = g.opts.min;
                        const maxOpt = g.opts.max;

                        //autoscaling
                        let minV =
                            typeof minOpt === "number" ? minOpt : Math.min(...hist, 0);
                        let maxV =
                            typeof maxOpt === "number" ? maxOpt : Math.max(...hist, 1);

                        if (maxV - minV < 1e-6) {
                            maxV = minV + 1;
                        }

                        const ctx = g.ctx;
                        const w = g.canvas.width;
                        const h = g.canvas.height;
                        ctx.clearRect(0, 0, w, h);

                        //background for nasty canvases
                        if (g.opts.background) {
                            ctx.fillStyle = g.opts.background;
                            ctx.fillRect(0, 0, w, h);
                        }

                        //draw the lines
                        const len = hist.length;
                        const step = (w - 4) / Math.max(buffer - 1, 1);

                        //begin a new path
                        ctx.beginPath();
                        for (let i = 0; i < len; i++) {
                            const v = hist[i];
                            const t = (v - minV) / (maxV - minV);
                            const y = h - 4 - t * (h - 8);
                            const x = 2 + (i - (buffer - len)) * step;
                            if (i === 0) {
                                ctx.moveTo(x, y);
                            } 
                            else {
                                ctx.lineTo(x, y);
                            }
                        }

                        //take the intergal haha
                        if (g.opts.fill && len > 0) {
                            ctx.lineTo(2 + (len - 1 - (buffer - len)) * step, h - 2);
                            ctx.lineTo(2 + (0 - (buffer - len)) * step, h - 2);
                            ctx.closePath();
                            ctx.fillStyle = Log._hexToRGBA(g.opts.color, 0.12);
                            ctx.fill();

                            //redraw the stroke path
                            ctx.beginPath();
                            for (let i = 0; i < len; i++) {
                                const v = hist[i];
                                const t = (v - minV) / (maxV - minV);
                                const y = h - 4 - t * (h - 8);
                                const x = 2 + (i - (buffer - len)) * step;
                                if (i === 0) {
                                    ctx.moveTo(x, y);
                                } 
                                else {
                                    ctx.lineTo(x, y);
                                }
                            }
                        }

                        ctx.strokeStyle = g.opts.color;
                        ctx.lineWidth = g.opts.strokeWidth;
                        ctx.stroke();

                        if (g.opts.showValue && len > 0) {
                            const last = hist[hist.length - 1];
                            ctx.font = "12px monospace";
                            ctx.fillStyle = g.opts.color;
                            ctx.textBaseline = "top";
                            ctx.fillText(`${key}: ${Number(last).toFixed(0)}`, 4, 2);
                        }
                    }
                }

                //rAF driven updating system. Trying to avoid crashing the main loop from all our graphiness
                /**
                 * Start the requestAnimationFrame-driven graph update loop.
                 * @private
                 */
                _startGraphAutoUpdate() {
                    if (this._graphAutoFrame) return;
                    const tick = () => {
                        if (!this.graphs || this.graphs.size === 0) {
                            this._graphAutoFrame = null;
                            return;
                        }
                        try {
                            this.updateGraphs();
                        } catch (e) {
                            /* swallow */
                        }
                        this._graphAutoFrame = requestAnimationFrame(tick);
                    };
                    this._graphAutoFrame = requestAnimationFrame(tick);
                }

                //what does this do?
                /**
                 * Stop the internal graph RAF loop.
                 * @private
                 */
                _stopGraphAutoUpdate() {
                    if (this._graphAutoFrame) {
                        cancelAnimationFrame(this._graphAutoFrame);
                        this._graphAutoFrame = null;
                    }
                }

                //I hate this function as much as you do. Allows me to use hex colors
                /**
                    * Convert a hex color or rgb/rgba string to an rgba() string with the provided alpha.
                    * @param {string} hex
                    * @param {number} [alpha=1]
                    * @returns {string}
                    */
                static _hexToRGBA(hex, alpha = 1) {
                    /* 
                        Color conversion. Fetched from stackoverflow with love
                    */
                    if (!hex) return `rgba(255,255,255,${alpha})`;
                    if (hex.indexOf("rgb") === 0) {
                        if (hex.indexOf("rgba") === 0)
                            return hex.replace(
                                /rgba\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/,
                                `rgba($1,$2,$3,${alpha})`,
                            );
                        return hex.replace("rgb", "rgba").replace(")", `, ${alpha})`);
                    }
                    let c = hex.replace("#", "");
                    if (c.length === 3)
                        c = c
                            .split("")
                            .map((ch) => ch + ch)
                            .join("");
                    const num = parseInt(c, 16);
                    const r = (num >> 16) & 255;
                    const g = (num >> 8) & 255;
                    const b = num & 255;
                    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
                }
            }
            const consolElement = document.getElementById("console");
            const consoleElement = document.getElementById("console");
            if (!consolElement) {
                document.body.insertAdjacentHTML(
                    "beforeend",
                    '<div id="console" style="position: fixed; bottom: 10px; left: 10px; border: 2px solid #333; padding: 10px; margin: 0; font-family: monospace; white-space: pre-wrap; background-color: rgba(25, 25, 25, 0.95); color: white; width: 45%; max-height: 250px; overflow: auto; z-index: 1000; border-radius: 4px;"></div>',
                );
            }
            let console = new Log("console");
            document.getElementById("console").style.display = "block";
            
            
            //want to make sure the judges actually read my code
            let shampoedNoodlesAndBacon = "soap";
            return {
                canvas: theCanvas,
                ctx: canvasContext,
                width,
                height,
                dprVal,
                displayScale,
                frameCount,
                firstFrame,
                lastTime,
                dtMs,
                dt,
                fps,
                cam,
                console,
                shampoedNoodlesAndBacon,
                windowResized,
            };
        })();
    </script>
    <script type>
        /* 
            @Judges - localStorage allows the browser to store keys and values and permits me to save the current state of the game to the browser so that the user doesn't have to start over after exiting the tab. Using a custom storage module allows me to more easily manipulate clearing storage (no weird interference) and ensure that the storage is split between the window opened and the KA window when in fullscreen
        */
        /**
         * Small wrapper around `localStorage` that prefers the opener window's storage when
         * running in a fullscreen/child context. Exposes the same API as `localStorage`.
         * @namespace storage
         * @property {(key:string)=>string|null} getItem
         * @property {(key:string,value:string)=>void} setItem
         * @property {(key:string)=>void} removeItem
         * @property {()=>void} clear
         */
        const storage = (() => {
            //use parent window's storage if in fullscreen otherwise use own
            const store = window.opener ? window.opener.localStorage : localStorage;
            return {
                getItem: (key) => store.getItem(key),
                setItem: (key, value) => store.setItem(key, value),
                removeItem: (key) => store.removeItem(key),
                clear: () => store.clear()
            };
        })();
        //storage.clear();
        //alert(JSON.stringify(storage));
    </script>
    <script type>
        /* 
            Graphic Helper functions. Math Helper Functions
        */
        let {
            getColor,
            fill,
            stroke,
            noStroke,
            noFill,
            strokeWeight,
            strokeCap,
            beginShape,
            endShape,
            vertex,
            curveVertex,
            quad,
            triangle,
            bezierVertex,
            bezier,
            line,
            point,
            rect,
            arcTo,
            arc,
            ellipse,
            pushMatrix,
            popMatrix,
            translate,
            random,
            lerp,
            map,
            constrain,
            dist,
            midpoint,
            mapToLine,
            edgeCheck,
            clamp,
            lerpAngle,
            normRandom,
            min
        } = (function helpers() {
            //color modes
            let Stroke = true;
            let Fill = true;

            /**
             * processes color inputs and returns a formatted RGBA color strind
             * grayscale, grayscale with alpha, RGB, or RGBA
             *
             * @param {number|Object} [n1] - red value (also gradient object)
             * @param {number} [n2] - green value (0-255) or alpha if no n3
             * @param {number} [n3] - blue value (0-255)
             * @param {number} [n4 = 255] - alpha value (0-255)
             * @returns {string|CanvasGradient} rgba string or grad
             */
            function getColor(n1 = 0, n2, n3, n4 = 255) {
                let r, g, b, a;

                if (n1?.isGrad) {
                    return n1.grad;
                }

                if (n2 === undefined) {
                    if (typeof n1 === "number" && (n1 < 0 || n1 > 255)) {
                        [r, g, b, a] = [red(n1), green(n1), blue(n1), alpha(n1)];
                    } else {
                        [r, g, b, a] = [n1, n1, n1, 255];
                    }
                } else if (n3 === undefined) {
                    if (typeof n1 === "number" && (n1 < 0 || n1 > 255)) {
                        [r, g, b, a] = [red(n1), green(n1), blue(n1), n2];
                    } else {
                        [r, g, b, a] = [n1, n1, n1, n2];
                    }
                } else {
                    [r, g, b, a] = [n1, n2, n3, n4];
                }
                const alphaNormalized = a / 255;
                return `rgba(${r}, ${g}, ${b}, ${alphaNormalized})`;
            }

            /**
             * Sets the fill color and enables filling
             * @param {number|string|Object} r - red, grayscale, hex, CSS string, or gradient
             * @param {number} [g] - green or alpha
             * @param {number} [b] - blue
             * @param {number} [aVal] - alpha
             */
            function fill(r, g, b, aVal) {
                if (typeof r === "string") {
                    ctx.fillStyle = r;
                } else {
                    ctx.fillStyle = getColor(r, g, b, aVal);
                }
                Fill = true;
            }

            /**
             * Sets the stroke color and enables outlining
             * @param {number|string|Object} r - Red, grayscale, hex, CSS string, or gradient
             * @param {number} [g] - Green or alpha
             * @param {number} [b] - Blue
             * @param {number} [aVal] - Alpha
             */
            function stroke(r, g, b, aVal) {
                if (typeof r === "string") {
                    ctx.fillStyle = r;
                } else {
                    ctx.strokeStyle = getColor(r, g, b, aVal);
                }
                Stroke = true;
            }

            /** disables shape outlines */
            function noStroke() {
                Stroke = false;
            }

            /** Disables shape fills */
            function noFill() {
                Fill = false;
            }

            /**
             * sets the stroke thickness
             * @param {number} s - line width in pixels.
             */
            function strokeWeight(s) {
                ctx.lineWidth = s;
            }

            /**
             * sets the style of line endings
             * @param {CanvasLineCap} cap - "butt", "round", or "square"
             */
            function strokeCap(cap) {
                ctx.lineCap = cap;
            }

            /** starts a new path */
            function beginShape() {
                ctx.beginPath();
            }

            /** fills and/or strokes the current path based on active settings */
            function endShape() {
                if (Fill) {
                    ctx.fill();
                }
                if (Stroke) {
                    ctx.stroke();
                }
            }

            /**
             * Adds a straight line to the path.
             * @param {number} x - Target X coordinate
             * @param {number} y - Target Y coordinate
             */
            function vertex(x, y) {
                ctx.lineTo(x, y);
            }

            /**
             * Adds a quadratic Bezier curve to the path.
             * @param {number} cx - Control point X
             * @param {number} cy - Control point Y.
             * @param {number} x - Anchor X
             * @param {number} y - Anchor Y.
             */
            function curveVertex(cx, cy, x, y) {
                ctx.quadraticCurveTo(cx, cy, x, y);
            }

            /**
             * Draws a four-sided polygon.
             * @param {number} x1..y4 - Coordinates for each corner.
             */
            function quad(x1, y1, x2, y2, x3, y3, x4, y4) {
                beginShape();
                vertex(x1, y1);
                vertex(x2, y2);
                vertex(x3, y3);
                vertex(x4, y4);
                vertex(x1, y1);
                endShape();
            }

            /**
             * Draws a three-sided polygon.
             * @param {number} x1..y3 - Coordinates for each corner.
             */
            function triangle(x1, y1, x2, y2, x3, y3) {
                beginShape();
                vertex(x1, y1);
                vertex(x2, y2);
                vertex(x3, y3);
                vertex(x1, y1);
                endShape();
            }

            /**
             * Adds a cubic Bezier curve to the path.
             * @param {number} cx1 - First control X.
             * @param {number} cy1 - First control Y.
             * @param {number} cx2 - Second control X
             * @param {number} cy2 - Second control Y.
             * @param {number} x - Anchor X.
             * @param {number} y - Anchor Y
             */
            function bezierVertex(cx1, cy1, cx2, cy2, x, y) {
                ctx.bezierCurveTo(cx1, cy1, cx2, cy2, x, y);
            }

            /**
             * Draws a cubic Bezier curve.
             * @param {number} x1,y1 - Start point.
             * @param {number} cx1,cy1 - First control point
             * @param {number} cx2,cy2 - Second control point.
             * @param {number} x2,y2 - End point.
             */
            function bezier(x1, y1, cx1, cy1, cx2, cy2, x2, y2) {
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                bezierVertex(cx1, cy1, cx2, cy2, x2, y2);
                ctx.stroke();
            }

            /**
             * Draws a straight line between two sets of coordinates.
             * @param {number} x1 - Starting X coordinate.
             * @param {number} y1 - Starting Y coordinate
             * @param {number} x2 - Ending X coordinate.
             * @param {number} y2 - Ending Y coordinate
             */
            function line(x1, y1, x2, y2) {
                beginShape();
                vertex(x1, y1);
                vertex(x2, y2);
                endShape();
            }

            /**
             * Draws a square point at the given coordinates.
             * @param {number} x,y - position.
             * @param {number} [s=2] - Point size
             */
            function point(x, y, s) {
                if (s === undefined) {
                    ctx.fillRect(x, y, 2, 2);
                }
                ctx.fillRect(x, y, s, s);
            }

            /**
             * Adds a circular arc to the current path using degrees.
             * @param {number} r - Diameter.
             * @param {number} start,stop - Angles in degrees
             */
            function arcTo(x, y, r, start, stop) {
                ctx.arc(x, y, r / 2, (start / 180) * Math.PI, (stop / 180) * Math.PI);
            }

            /**
             * draws a scaled arc - see arcTo
             * @param {number} w,h - width and height
             */
            function arc(x, y, w, h, start, stop) {
                ctx.save();
                ctx.translate(x, y);
                ctx.scale(1, h / w);
                beginShape();
                arcTo(0, 0, w, start, stop);
                endShape();
                ctx.restore();
            }

            /**
             * Draws an ellipse or circle at the specified coordinates.
             * @param {number} x - Center X coordinate.
             * @param {number} y - Center Y coordinate
             * @param {number} w - Width of the ellipse.
             * @param {number} h - Height of the ellipse.
             */
            function ellipse(x, y, w, h) {
                w = Math.abs(w);
                h = Math.abs(h);
                arc(x, y, w, h, 0, 360);
            }

            /** saves the previous drawing state/transform */
            function pushMatrix() {
                ctx.save();
            }

            /** restores the previous drawing state/transform. */
            function popMatrix() {
                ctx.restore();
            }

            /**
             * Shifts the drawing origin.
             * @param {number} x - Horizontal offset.
             * @param {number} y - Vertical offset.
             */
            function translate(x, y) {
                ctx.translate(x, y);
            }

            /**
             * Returns the unit sign of a number (-1, 1, or 0).
             * @param {number} x - Input value.
             * @returns {number}
             */
            function sign(x) {
                return abs(x) / x || 0;
            }

            /**
             * Generates a random number within a range.
             * @param {number} min - Minimum value.
             * @param {number} max - Maximum value.
             * @returns {number}
             */
            function random(min, max) {
                return Math.random() * (max - min + 1) + min;
            }

            /**
             * Linearly interpolates between two values.
             * @param {number} num1 - Start value.
             * @param {number} num2 - End value.
             * @param {number} amt - Interpolation amount (0.0 to 1.0).
             * @returns {number}
             */
            function lerp(num1, num2, amt) {
                return num1 + (num2 - num1) * amt;
            }

            /**
             * Re-maps a number from one range to another.
             * @param {number} num - Value to map.
             * @param {number} start1,stop1 - Original range.
             * @param {number} start2,stop2 - Target range.
             * @returns {number}
             */
            function map(num, start1, stop1, start2, stop2) {
                return start2 + ((num - start1) / (stop1 - start1)) * (stop2 - start2);
            }

            /**
             * Constrains a value between a minimum and maximum.
             * @param {number} num - Value to limit.
             * @returns {number}
             */
            function constrain(num, min, max) {
                return Math.max(Math.min(num, max), min);
            }

            /**
             * Calculates the Euclidean distance between two 2D points.
             * @param {number} x1 - First X coordinate.
             * @param {number} y1 - First Y coordinate.
             * @param {number} x2 - Second X coordinate.
             * @param {number} y2 - Second Y coordinate.
             * @returns {number} The distance between points.
             */
            function dist(x1, y1, x2, y2) {
                return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
            }

            /**
             * Calculates the midpoint between two 2D points.
             * @param {number} Ax - First X coordinate.
             * @param {number} Bx - Second X coordinate.
             * @param {number} Ay - First Y coordinate.
             * @param {number} By - Second Y coordinate.
             * @returns {number[]} A coordinate pair as [x, y].
             */

            function midpoint(Ax, Bx, Ay, By) {
                var mx = (Ax + Bx) / 2;
                var my = (Ay + By) / 2;

                return [mx, my];
            }

            /**
             * Interpolates a point along a line segment by a percentage.
             * @param {number} x1,y1 - Start coordinates.
             * @param {number} x2,y2 - End coordinates.
             * @param {number} percentage - Interpolation factor (0.0 to 1.0).
             * @returns {{x: number, y: number}} The resulting point object.
             */
            function mapToLine(x1, y1, x2, y2, percentage) {
                return {
                    x: x1 * (1.0 - percentage) + x2 * percentage,
                    y: y1 * (1.0 - percentage) + y2 * percentage,
                };
            }

            /**
             * Detects Axis-Aligned Bounding Box (AABB) collision between two objects.
             * @param {Object} a - First object with x, y, w, h properties.
             * @param {Object} b - Second object with x, y, w, h properties.
             * @returns {boolean} True if objects overlap.
             */
            function edgeCheck(a, b) {
                return (
                    a.x + a.w > b.x &&
                    a.x < b.x + b.w &&
                    a.y + a.h > b.y &&
                    a.y < b.y + b.h
                );
            }

            /**
             * Restricts a value within a specified range.
             * @param {number} v - Value to clamp.
             * @param {number} a - Minimum bound.
             * @param {number} b - Maximum bound.
             * @returns {number}
             */
            function clamp(v, a, b) {
                return Math.max(a, Math.min(b, v));
            }

            /**
             * Linearly interpolates between two angles in radians, handling wrap-around.
             * @param {number} a - Start angle.
             * @param {number} b - End angle.
             * @param {number} t - Interpolation amount (0.0 to 1.0).
             * @returns {number}
             */
            function lerpAngle(a, b, t) {
                let diff = ((b - a + Math.PI * 3) % (Math.PI * 2)) - Math.PI;
                return a + diff * t;
            }

            /**
             * Draws a rectangle with support for individual corner radii.
             * Supports rounded (positive) or scalloped (negative) corners.
             *
             * @param {number} x - Top-left X coordinate.
             * @param {number} y - Top-left Y coordinate.
             * @param {number} w - Rectangle width.
             * @param {number} h - Rectangle height.
             * @param {number} [r1=0] - Top-left radius (default for all corners).
             * @param {number} [r2] - Top-right radius.
             * @param {number} [r3] - Bottom-right radius.
             * @param {number} [r4] - Bottom-left radius.
             */
            function rect(x, y, w, h, r1 = 0, r2, r3, r4) {
                const maxR = Math.min(w, h) / 2;
                const limit = (val) => Math.max(-maxR, Math.min(val, maxR));
                const [tr1, tr2, tr3, tr4] = [r1, r2 ?? r1, r3 ?? r1, r4 ?? r1].map(limit);

                ctx.beginPath();

                ctx.moveTo(x, y + tr1);
                curveVertex(x, y, x + tr1, y);

                vertex(x + w - tr2, y);
                curveVertex(x + w, y, x + w, y + tr2);

                vertex(x + w, y + h - tr3);
                curveVertex(x + w, y + h, x + w - tr3, y + h);

                vertex(x + tr4, y + h);
                curveVertex(x, y + h, x, y + h - tr4);

                ctx.closePath();
                ctx.fill();
            }

            /**
             * generates a random number between 0 and 1 with a normal distribution
             *
             * @returns {number} value between 0 and 1
             */
            function gaussianRandom() {
                var sampSize = 7;
                var rand = 0;
                for (var i = 0; i < sampSize; i += 1) {
                    rand += Math.random();
                }
                return rand / sampSize;
            }

            /**
             * Generates a random integer within a specified range following a bell curve (gaussian)
             *
             * @param {number} start - the lower bound of the range (inclusive
             * @param {number} end - the upper bound of the range (inclusive).
             * @returns {number} A randomized integer biased toward the center of the range
             */
            function normRandom(start, end) {
                return Math.floor(start + gaussianRandom() * (end - start + 1));
            }
            
            /**
             * Returns the smaller number of two inputs
             *
             * @param {number} start - the lower bound of the range (inclusive
             * @param {number} end - the upper bound of the range (inclusive).
             */
            function min(a, b) {
                let answer = a;
                if(b < answer){
                    answer = b;
                }
                return answer;
            }
            
            return {
                getColor,
                fill,
                stroke,
                noStroke,
                noFill,
                strokeWeight,
                strokeCap,
                beginShape,
                endShape,
                vertex,
                curveVertex,
                quad,
                triangle,
                bezierVertex,
                bezier,
                line,
                point,
                rect,
                arcTo,
                arc,
                ellipse,
                pushMatrix,
                popMatrix,
                translate,
                sign,
                random,
                lerp,
                map,
                constrain,
                dist,
                midpoint,
                mapToLine,
                edgeCheck,
                clamp,
                lerpAngle,
                normRandom,
                min,
                //triangle,
            };
        })();
    </script>
    <script type>
        /* 
            User input, Image loading, Graphics
        */
        /**
         * Initialize user input helpers and an image cache used by the renderer
         * Exposes `keys`, `mouse`, `cache`, and `img` for global use.
         * @returns {{keys:Object, mouse:Object, cache:Cache, img:Function}}
         */
        const { keys, mouse, cache, img } = (function gameSetup() {
            //user input methods
            let k = {};
            let m = {
                x: 0,
                y: 0,
                clicked: false,
                rightClicked: false,
                rightReleased: false,
                released: false,
                down: false,
                up: false,
            };
            //the image cache. Loads images into the canvas
            const imagesToLoad = [
                {
                    display: function () {
                        try {
                            if(window.opener){
                                
                            }
                            
                            /* 
                                @Judges - A overlay to create a texture that covers the screen. I was unsure whether or not I liked it, so fullscreen doesn't have one and the KA Iframe does. Pick your poison.
                                As a side note: Using a Uint32Array and a SEPERATE, OFF-SCREEN, canvas makes this blazing fast
                            
                            */
                            const overlay = new ImageData(width, height);
                            const buf = new Uint32Array(overlay.data.buffer);
                            
                            for (let i = 0; i < buf.length; i++) {
                                const seq = Math.random();
                                const r = (seq * 60 + 25) | 0;
                                const g = (seq * 40 + Math.random() * 50) | 0;
                                const b = (seq * 60 + Math.random() * 100 - 50) | 0;
                            
                                //ABGR
                                buf[i] = (255 << 24) | (b << 16) | (g << 8) | r;
                            }
                            octx.putImageData(overlay, 0, 0);

                        } catch (e) {
                            console.error("Image Cache error" + JSON.stringify(e));
                        }
                    },
                    w: width,
                    h: height,
                },
                {
                    display: function () {},
                    w: 600,
                    h: 600,
                },
            ];
            Cache = (function () {
                /**
                 * Simple image cache that pre-renders small bitmaps using OffscreenCanvas
                 * and stores ImageBitmap objects for fast drawing.
                 * @constructor
                 */
                Cache = function (that) {
                    this.loaded = false;
                    this.imgIndex = 0;
                    this.curImg = {};
                    this.img = [];
                };
                Cache.prototype = {
                    /**
                     * Kick off loading/processing of images defined in `imagesToLoad`.
                     * Uses OffscreenCanvas.transferToImageBitmap for performance.
                     * @returns {boolean|undefined} Returns true when fully loaded.
                     */
                    load: function () { 
                        /* 
                            @Judges - This thing is blazing fast because it is running with transferToImageBitmap() and another offscreen canvas
                        */
                        if (this.imgIndex < imagesToLoad.length) {
                            (async () => {
                                this.curImg = imagesToLoad[this.imgIndex];
                                this.curImg.display();
                
                                //use OffscreenCanvas for background processing (Faster than DOM Canvas)
                                const offscreen = new OffscreenCanvas(this.curImg.w, this.curImg.h);
                                const osCtx = offscreen.getContext('2d');
                
                                //GPU-accelerated alpha
                                osCtx.globalAlpha = 0.2;
                                osCtx.drawImage(ctx.canvas, 0, 0, this.curImg.w, this.curImg.h, 0, 0, this.curImg.w, this.curImg.h);
                
                                //transferToImageBitmap
                                const bmp = offscreen.transferToImageBitmap();
                                
                                this.img.push(bmp);
                                this.imgIndex++;
                                
                                // this.load(); 
                            })();
                        } else {
                            return (this.loaded = true);
                        }
                    },
                };

                return Cache;
            })();
            let _cache = new Cache();

            /**
             * Convenience wrapper around `ctx.drawImage` that only draws when the cache is ready.
             * @param {CanvasImageSource|ImageBitmap} that - Image or bitmap to draw.
             * @param {number} x - Destination X coordinate.
             * @param {number} y - Destination Y coordinate.
             * @returns {void}
             */
            function img(that, x, y) {
                if (_cache.loaded) {
                    return ctx.drawImage(that, x, y);
                }
            }
            
            return {
                keys: k,
                mouse: m,
                cache: _cache,
                img: img,
            };
        })();
    </script>
    <script type>
        /**
         * Wrapper around the Web Audio API for decoding and playing a base64-encoded audio buffer.
         * Creates its own AudioContext, gain node, and buffer source. The source is created on
         * demand and configured to loop.
         *
         * Created by Arrow
         * Docs: https://www.khanacademy.org/computer-programming/ka-music-player/5424847674523648
         */
        class AudioBuffer {
            constructor() {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                this.source = null;
                this.buffer = null;
                this.gainNode = this.audioContext.createGain();
                this.gainNode.connect(this.audioContext.destination);
            }
            /**
             * Sets the internal base64-encoded audio string and decodes it.
             * @param {string} audioBufferString - A data URL or base64 audio string (e.g. "data:audio/mpeg;base64,...").
             * @returns {Promise<void>} Resolves when the audio buffer has been decoded.
             */
            async setBase64String(audioBufferString) {
                this.audioBufferString = audioBufferString;
                await this._initializeBuffer();
            }
            
            /**
             * Internal: decodes the stored base64 audio string into an AudioBuffer.
             * @private
             * @returns {Promise<void>}
             */
            async _initializeBuffer() {
                const binaryString = atob(this.audioBufferString.split(',')[1]);
                const bytes = Uint8Array.from(binaryString, char => char.charCodeAt(0));
                this.buffer = await this.audioContext.decodeAudioData(bytes.buffer);
            }

            /**
             * Internal: creates and configures a BufferSource node connected to the gain node.
             * The source is configured to loop.
             * @private
             */
            _createSource() {
                this.source = this.audioContext.createBufferSource();
                this.source.buffer = this.buffer;
                this.source.connect(this.gainNode);
                //loop!
                this.source.loop = true;
            }
            
            /**
             * Starts playback. If the AudioContext is suspended it will be resumed first.
             * If a source has not been created yet it will create one and start it.
             */
            play() {
                if (this.audioContext.state === 'suspended') {
                    this.audioContext.resume();
                }
                if (!this.source) {
                    this._createSource();
                    this.source.start(0);
                }
            }
            
            /**
             * Stops and releases the current source if present.
             */
            pause() {
                if (this.source) {
                    this.source.stop();
                    this.source = null;
                }
            }
            
            /**
             * Sets the gain (volume) of playback.
             * @param {number} volume - Linear gain value (0.0 = silent, 1.0 = original volume).
             */
            setVolume(volume) {
                this.gainNode.gain.value = volume;
            }
        }

        //initialize audio
        let gameAudio = null;
        let isMuted = false;

        /**
         * Initializes the global `gameAudio` instance by decoding the embedded base64 music
         * (from `dungeonMusic`) and starts playback. Errors are logged to the console.
         * @returns {Promise<void>}
         */
        async function initAudio() {
            gameAudio = new AudioBuffer();
            try {
                await gameAudio.setBase64String("data:audio/mpeg;base64," + matchMusic);
                gameAudio.setVolume(1);
                gameAudio.play();
            } catch (e) {
                console.error("failed to load audio:", e);
            }
        }

        //audio button handler
        const audioButton = document.getElementById("audio");
        if (audioButton) {
            audioButton.addEventListener("click", () => {
                if (!gameAudio) {
                    initAudio();
                    return;
                }
                
                isMuted = !isMuted;
                if (isMuted) {
                    gameAudio.setVolume(0);
                    audioButton.textContent = "volume_off";
                } 
                else {
                    gameAudio.setVolume(1);
                    audioButton.textContent = "volume_up";
                }
            });
        }

        //start
        document.addEventListener("click", () => {
            if (!gameAudio) {
                initAudio();
            }
        }, { once: true });
    </script>
    <script type>
        //arrow being arrow
        const PixelArt = (() => {
            const PAL = {
                'a':[224,221,211,255],
                'b':[65,11,11,255],
                'c':[112,18,17,255],
                'd':[133,24,24,255],
                'e':[21,65,11,255],
                'f':[27,82,15,255],
                'g':[29,95,14,255],
                'h':[17,66,89,255],
                'i':[24,95,129,255],
                'j':[28,110,150,255],
                'k':[39,18,50,255],
                'l':[52,25,67,255],
                'm':[65,31,84,255],
            };
            
            const GFX = [
                // Red Tiles
                [
                    " bbbbbbbbbbbbbbbbb",
                    "bbdddddddddddddddbb",
                    "bccccccccbdcccccddb",
                    "bccccccccbdccccccdb",
                    "bccccccccbddcccccdb",
                    "bcccccccbbbdcccccdb",
                    "bbccccccbbbdcccccdb",
                    "bbcccddddddddddccdb",
                    "bbcccbbdbbbdbbddddb",
                    "bbbbbbbdbcbdbbbbbdb",
                    "bbcccbbcbbbdbbcccdb",
                    "bbcccccccdddcccccdb",
                    "bbccccccbbbdcccccdb",
                    "bbccccccbbbccccccdb",
                    "bbcccccccbcccccccdb",
                    "bbcccccccbcccccccdb",
                    "bbbccccccbcccccccdb",
                    "bbbbbbbbbbbbbccccbb",
                    " bbbbbbbbbbbbbbbbb",
                ],
                [
                    "      bbaaaaabb",
                    "       bbaaabb",
                    "        bbabb",
                    "         bbb",
                ],
                [
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "                  b",
                    "                 bb",
                    "                bba",
                    "               bbaa",
                    "               baaa",
                    "               bbaa",
                    "                bba",
                    "                 bb",
                    "                  b",
                ],
                [
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "         bbb",
                    "        bbabb",
                    "       bbaaabb",
                    "      bbaaaaabb",
                ],
                [
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "b",
                    "bb",
                    "abb",
                    "aabb",
                    "aaab",
                    "aabb",
                    "abb",
                    "bb",
                    "b",
                ],
                
                //Green Tiles
                [
                    " eeeeeeeeeeeeeeeee",
                    "eefffffffffffffffee",
                    "efffggggfgggggggffe",
                    "efffeeegfeeeeeeggfe",
                    "effeeeegfeeeeeeegfe",
                    "effeeefffffffeeegfe",
                    "eefeefffffffffeegfe",
                    "eefeefffggggffffffe",
                    "eefeefffeeegffgggfe",
                    "eefeefffeeegffeegfe",
                    "eeffffffeeegffeegfe",
                    "eefgggffffffffeegfe",
                    "eefeeggfffffffeegfe",
                    "eefeeegggggffeeegfe",
                    "eefeeeeeeegfeeeegfe",
                    "eeffeeeeeegfeeefffe",
                    "eeefffffffffffffffe",
                    "eeeeeeeeeeeeeffffee",
                    " eeeeeeeeeeeeeeeee",
                ],
                [
                    "      eeaaaaaee",
                    "       eeaaaee",
                    "        eeaee",
                    "         eee",
                ],
                [
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "                  e",
                    "                 ee",
                    "                eea",
                    "               eeaa",
                    "               eaaa",
                    "               eeaa",
                    "                eea",
                    "                 ee",
                    "                  e",
                ],
                [
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "         eee",
                    "        eeaee",
                    "       eeaaaee",
                    "      eeaaaaaee",
                ],
                [
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "e",
                    "ee",
                    "aee",
                    "aaee",
                    "aaae",
                    "aaee",
                    "aee",
                    "ee",
                    "e",
                ],
                
                //Blue Tiles
                [
                    " hhhhhhhhhhhhhhhhh",
                    "hhjjjjjjjjjjjjjjjhh",
                    "hiihiiiiiiiiiiihjjh",
                    "hihihiiiiiiiiihihjh",
                    "hiihhiiiiiiiiihhijh",
                    "hiiiiihhhhhhhiiiijh",
                    "hhiiihhhhhhhhhiiijh",
                    "hhiiihhiiiiihhiiijh",
                    "hhiiihhiijjihhiiijh",
                    "hhiiihhiiijihhiiijh",
                    "hhiiihhiiiiihhiiijh",
                    "hhiiihhiiiiihhiiijh",
                    "hhiiihhhhhhhhhiiijh",
                    "hhiiiihhhhhhhiiiijh",
                    "hhihhiiiiiiiiihhijh",
                    "hhhihiiiiiiiiihihjh",
                    "hhhhiiiiiiiiiiihijh",
                    "hhhhhhhhhhhhhiiiihh",
                    " hhhhhhhhhhhhhhhhh",
                ],
                [
                    "      hhaaaaahh",
                    "       hhaaahh",
                    "        hhahh",
                    "         hhh",
                ],
                [
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "                  h",
                    "                 hh",
                    "                hha",
                    "               hhaa",
                    "               haaa",
                    "               hhaa",
                    "                hha",
                    "                 hh",
                    "                  h",
                ],
                [
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "         hhh",
                    "        hhahh",
                    "       hhaaahh",
                    "      hhaaaaahh",
                ],
                [
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "h",
                    "hh",
                    "ahh",
                    "aahh",
                    "aaah",
                    "aahh",
                    "ahh",
                    "hh",
                    "h",
                ],
                // Bomb tiles
                [
                    " kkkkkkkkkkkkkkkkk",
                    "kkmmmmmmmmmmmmmmmkk",
                    "klllllllllllllllmmk",
                    "kllmmmmlmmmlmmmmlmk",
                    "kllmkkklmkmlkkkmlmk",
                    "kllmkmmlmkmlmmkmlmk",
                    "kklmkmklmkmlkmkmlmk",
                    "kklllllllllllllllmk",
                    "kklmmmmlmmmlmmmmlmk",
                    "kklmkkklmkmlkkkmlmk",
                    "kklmmmmlmmmlmmmmlmk",
                    "kklllllllllllllllmk",
                    "kklmkmllmkmllmkmlmk",
                    "kklmkmmlmkmlmmkmlmk",
                    "kklmkkklmkmlkkkmlmk",
                    "kkkmmmmlmmmlmmmmlmk",
                    "kkkklllllllllllllmk",
                    "kkkkkkkkkkkkkllllkk",
                    " kkkkkkkkkkkkkkkkk",
                ],
                [
                    "      kkaaaaakk",
                    "       kkaaakk",
                    "        kkakk",
                    "         kkk",
                ],
                [
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "                  k",
                    "                 kk",
                    "                kka",
                    "               kkaa",
                    "               kaaa",
                    "               kkaa",
                    "                kka",
                    "                 kk",
                    "                  k",
                ],
                [
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "         kkk",
                    "        kkakk",
                    "       kkaaakk",
                    "      kkaaaaakk",
                ],
                [
                    "",
                    "",
                    "",
                    "",
                    "",
                    "",
                    "k",
                    "kk",
                    "akk",
                    "aakk",
                    "aaak",
                    "aakk",
                    "akk",
                    "kk",
                    "k",
                ],
            ]; 


            const W = 19, H = 19;
            
            //bake me a cake as fast as you can >:)
            function bake(rows) {
                const oc = document.createElement('canvas');
                oc.width = W; oc.height = H;
                const ox = oc.getContext('2d');
                const img = ox.createImageData(W, H);
                const d = img.data;
                for (let y = 0; y < rows.length && y < H; y++) {
                    const row = rows[y];
                    for (let x = 0; x < row.length && x < W; x++) {
                        const p = PAL[row[x]];
                        if (!p) continue;
                        const i = (y * W + x) * 4;
                        d[i]=p[0]; 
                        d[i+1]=p[1]; 
                        d[i+2]=p[2]; 
                        d[i+3]=p[3];
                    }
                }
                ox.putImageData(img, 0, 0);
                return oc;
            }

            //bake all 20 layers up-front
            const C = GFX.map(bake);

            return {
                /**
                 * Draw a pixel-art tile and its active side indicators.
                 * Replaces all vertex-art drawing in the actual tile draw thingy
                 */
                draw(ctx, colorIndex, sides, cx, cy, size, opacity, scale, isDragging, grayed = false) {
                    const base = colorIndex * 5;
                    ctx.save();
                    ctx.globalAlpha = opacity;
                    ctx.translate(cx, cy);
                    ctx.scale(scale, scale);
                    ctx.imageSmoothingEnabled = false;

                    const dx = -size / 2, dy = -size / 2;
                    const px = size / W;
                    ctx.drawImage(C[base], dx, dy, size, size);
                    // graying
                    if (grayed) {
                        ctx.fillStyle = "#7f7f7f44";
                        ctx.fillRect(dx, dy, size, size)
                    }
                    if (sides.up) ctx.drawImage(C[base + 1], dx - px, dy, size, size);
                    if (sides.right) ctx.drawImage(C[base + 2], dx, dy - px, size, size);
                    if (sides.down) ctx.drawImage(C[base + 3], dx - px, dy, size, size);
                    if (sides.left) ctx.drawImage(C[base + 4], dx, dy - px, size, size);
                    

                    //drag highlight
                    if (isDragging) {
                        ctx.strokeStyle = 'rgba(255, 255, 180, 0.9)';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(dx + 1, dy + 1, size - 2, size - 2);
                    }

                    ctx.restore();
                    ctx.globalAlpha = 1;
                }
            };
        })();

        const MenuScreen = (() => {
            function toCSS([r, g, b, a]) {
                return `rgba(${r},${g},${b},${(a / 255).toFixed(3)})`;
            }
            
            function bakeSprite(drawing, palette) {
                const cols = drawing[0].length;
                const rows = drawing.length;
                const oc = document.createElement("canvas");
                oc.width = cols;
                oc.height= rows;
                const ox = oc.getContext("2d");
                const img = ox.createImageData(cols, rows);
                const d = img.data;

                for (let r = 0; r < rows; r++) {
                    const row = drawing[r];
                    for (let c = 0; c < cols; c++) {
                        const ch  = row[c];
                        const pal = palette[ch];
                        if (!pal) continue;            
                        const idx = (r * cols + c) * 4;
                        d[idx] = pal[0];
                        d[idx + 1] = pal[1];
                        d[idx + 2] = pal[2];
                        d[idx + 3] = pal[3];
                    }
                }
                ox.putImageData(img, 0, 0);
                return oc;
            }

            
            
            
            const Background = {
                palette: {
                    " ": [255, 0, 0, 0],
                    "a": [0, 0, 0,255],
                    "b": [16,18, 33,255],
                    "c": [31, 35, 59,255],
                    "d": [48, 53,87, 255],
                    "e": [161, 161, 161,255],
                    "f": [56, 56, 56, 255],
                    "g": [60, 65,110,255],
                    "h": [183, 184, 204,255],
                    "i": [73, 73, 84, 255],
                    "j": [105,111, 125,255],
                    "k": [61, 8, 11, 255],
                    "l": [148,18, 27, 255],
                    "m": [20, 71, 10, 255],
                    "n": [33, 125, 15, 255],
                    "o": [9, 19,71,255],
                    "p": [16, 31,  110, 255],
                },
                data: [
                    "aabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbccccccdddddcccccccccccccccdddccccccccccaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
                    "aabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbccccccccddccccccccccccccccccccddccccccccccbbbbbbbbbbbbbbbbbbbbaaaaaaaaaaaaaaaaaaaaaaaaaa",
                    "aabbbbbbbbbbbbbbbbbbbbbbbbcbbbbbbbbbbbbccccccccddccccccccddddddddcccccccddccccccccbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbeeeeeeeeffaa",
                    "aabbbbbbbbbbbcbbbbbbbgbbbbbbbbbbbbbbbbccccdcccddcccccccddddddddddddcccccddccccccccbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbeeeeeeeeffff",
                    "aabbbbbgbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbcccddcccddcccccddddddddddddddddccccddccccccccbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbeeeeeeeeffff",
                    "aabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbcccdccccdcccccddddgggggggggdddddcccdddcccccccbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbeeeeeeeeffff",
                    "aabbbbbbbbbbbbbbbbbbbbcbbbbbbbbbcbbbbbccddcccddcccddddgggghhhhhggggddddcccddcccccccbbbbbbbbbbbbbbbbbbbbbbbbbbbbgbbcbeeeeeeeeffff",
                    "aabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbcccddcccddcccdddgggghhhhhhhhgggddddccddcccccccbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbeeeeeeeeffff",
                    "aabbbbbffebbbbbbbbbbbbbbbbbbbbbbbbbbbcccdccccdccccdddggghhhhhhheehggddddcccddcccccccbbbbbbbbbbgbbbbbbbbbbbbbbbbbbbbbeeeeeeeeffff",
                    "aabbbffffeiiebbbbcbbbbbbbbbbbbbbbbbbbccddcccddcccdddgghhhhhhhhhhehhggdddcccddcccccccbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbeeeeeeeeffff",
                    "abbbfffieiieebbbbbbbbbbbbbbbcbbbbbbbbccddcccddcccdddgghheheeehehhhhggdddcccdddcccccccbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbeeeeeeeeffff",
                    "abbffffeeeieeeebbbbbbbbbbbbbbbbbbbbbbccddcccddcccdddghheeeeeeehhhhhhgdddccccddcccccccbbbbbbbbbbbbbbbbbbbbbcbbbbbbbbbeeeeeiifffff",
                    "abbffffeeeeeeeeeeebbbbbbbgbbbbbbbbbbcccdccccdddccdddgheheeeeeeehhhehggdddcccddccccccccbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbeeeiiiiiffff",
                    "abbffffeeeeeeeeeeeeebbbbbbbbbbbbbbbbcccdccccdddccdddgheeeeheeeehhhehggdddcccddccccccccbbbbbbcbbbbbbbbbbbbbbbbbbbbbbbiiiieeefffff",
                    "abbffffeeeeeeeeeeeeeeeibbbbbbbbbbbbbcccdccccdddccdddgeeehhhheehhhhhhggdddcccddcccdccccbbbbbbbbbbbbgbbbbbbbbbbbbbbbbbeeeieeefffff",
                    "abbffffffeeeeeeeeeeeeeieebbbbbbbbbbbccccccccdddccdddgeeehhhhhhehhhhhgddddcccddccccdcccbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbeeeieeefffff",
                    "abbbffeeiffieeeeeeeeeeeeeebbbbbbbbbbccccdccccddccdddgdhhhhhhhhhhhhhggddddcccddcccddcccbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbeeeieeefffff",
                    "abbbffeeeiiifieeeeeeeeeeeeebbbbbbbbbcccddccccddcccdddghhhheehhhhhhhggddddcccdcccdddcccbbbbbbbbbbbbbbbbbbbbbbbbbcbbbbeeeieeefffff",
                    "abbfffeeeeeefffieeeeeeeeeeebbbcbbbbbcccddcccccdcccdddgghheeeeeeehhggddddcccddcccdcccccbbbbbbbbbbbcbbbbbbbbbbbbbbbbbbeeeieeefffff",
                    "abbfffeeeeeefffffeeeeeeeeeebbcbbbbbbcccddcccccddcccddddghhhheeehhggdddddcccddcccdccccbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbeeeieeefffff",
                    "abffffeeeeeebbfffffiieeeeeebbcbbbbbbccccddcccccddccdddddgggghhhgggdddddccccdccccdccccbbbbbbbbbbbbbbbbbbbbcbbbbbbbbbbeeeieeefffff",
                    "abffffeeeeeebbbbfffffffeeeebbbcbbbbcbcccdddccccdddccddddddgggggggdddddccccdccccccccccbbbbbbbbcbbbbbbbbbbbbbbbbbbbbbbeeeeeeefffff",
                    "abffffeeeeeebbbbbbbfiiiffeebbbcbbbbbbcccccdccccccdcccddddddddddddddddccccddccccccccccbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbeeeeeeefffff",
                    "abffffeeeeeebbbbbbffieeiiffbbbcbbbbbbbccccdcccccccddccdddddddddddddddccccdccccdcccccbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbeeeeeeefffff",
                    "abffffieeeeebbbcbbffieeeebbbbbbcbbbbbbcccccccccccccddcccdddddddddddccccdddcccdccccccbbbdbbbbbbbbbbbbbbbbbbbbbbbbbbbbeeeeeeefffff",
                    "abffffeeeeeebbbbbbffieeeebbbbbbcbbcbbbbcccccccccccccdddccccccccccccccddddcccddcccccbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbeeeeeeefffff",
                    "abffffeeeeeebbbbbbffieeeebbbbbbbbbbbbbbbccccccddccccccddcccccccccccddddcccccdcccccbbbbbbbbbbbbbbbbbbdbbbbbbbbbbbbbbbeeeeeeefffff",
                    "abffffeeeeeebbbgbbffieeeebbcbbbbbfibbbbbccccccdddcccccccccccccccddddcccccccddccccbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbeeeeeeefffff",
                    "abffffeeeeeebcbbbbffieeeebbcbbbfffeeebbbbbcccccdddcccccccccddddddcccccccccddccccbbbbbbbbbbbbbbbbbbbbbbbbbbbbcbbbbbbbieeeiiffffff",
                    "abffffeeeeeebbbbbbffieeeebbbcbbfffeeeeiieeccccccddccccccccccddddccccccccccdcccccbbbbbbcbbbbbbbbbiiiiibbbbbbbbbbbbbbbiiiiieefffff",
                    "abffffeeeeeebbbbbbffiieeebbbcbbfffeeeeieeeeeeccccdddcccccccccccccccccccccdcccccbbbbbbbbbbbbbbbiiiiiiifbbbbbbbbbbbbbbeeeieeefffff",
                    "abbfffiiieeebbbbbfffiieeebbbbbbfffeeeeieeeeeeeecccddddccccccccccccccdcccdccccccbbbbbbbbbiiiiffiiiiiiiffbbbbbbbccbbbbeeeieeefffff",
                    "abbfffeeiiibbbabbfffiieeebbbbbcfffeeeeiieeeeeeeeeedddddddccccccccdddccccccccccbbbbbbbeiiiiiiiiiiiiiiiffbbbbbbcbbbbbbeeeieeefffff",
                    "abbfffeeeeebbbabafffieeeibbbbbcffffeeeiieeeeeeeeeeeccdddddddccccdcccccccccccebbbeeibieiiiiiiiiiiiiiiiffbbbbbcbbbbbbbeeeieeefffff",
                    "bbffffeeeeeebbaaafffieeeibbbbbccffiiiffieeeeeeeeeeeccccccccccccccccccccccccceeeeeeiieeiiiiiiiiiiiiiiiffbbbbcbbbbbbcbeeeieeffffff",
                    "bffffeeeeeebbabbffffiiibbabbbbcffeeebffffieeeeeeeebcccccccccccccccccccccccbbeeeeeeeeeeiiiiiiiiiiiffifffbbbcbbbbbccbbeeiiiiifffff",
                    "bffffeeeeeebbabbfffieeiaaaabbbcffeeebbbfffffeeeeeebbcccccccccccccccccccccbbeeeeeeeeiiiiiiiiifffffieiffbbccbbbbbcbbbbiiiieeifffff",
                    "bffffeeeeeebbabbfffieeeaaaabbbbffeeebbbbbbbfffffeebbbbcccccccccccccccbbbbbbeeeeeeeeiiiiiffffffbbbieifbbbbbbbbbbcbbbbeeeieeifffff",
                    "bffffeeeeeebbaaafffieeeabaaaaabffeeebbbbbbbbbfiiibbbbbbbbbccccccbbbbbbbbbbbeeeeeiiiifffffffbbbbbbieiffbbbbbbcccbbbbeeeeeeeffffff",
                    "bffffeeeeeebbabbfffieeeabaabaabffieeccabbbdbffiiebbbbbbbbbbbbbbbbccbbbbbbbbbeeeefffffffbbbbbbbbbbeeiffbbbbbbbbbbbbceeeeeeeffffff",
                    "bfffieeeeeebbabbfffieeeabaaaabbffiiiacaabbbbffiiebbbbbbbbbbbbbbbbbbbbbbbbbbbifffffffbbbbbbbbbbbbbeeiffbbbbbbbbbbccceeeeeeeffffff",
                    "bfffieeeeeebbaaafffffiaaaabaabffieiiaaaaabbbffiiebbbbbbbbbbbbbbbbcbbbbbbbbbeeiifbbbbbbbbbbbbbbbbbeiiffbbbbbbbbcccddeeeeeeeffffff",
                    "bbffieeeeebbbabbfffieeabbabaabffieeeacbaabbaffiiecbbbbbbbbbbbgbbbbbbbbbbbbbeeiiffbbbbbbbbbbbbbbbbieiffbbbbbbccccdddeeeeeeeffffff",
                    "bbffieeeeabbbabbfffieeabbabaabffieeeabbabaaafffieccccbbbbbbbbbbbbbbbbbbbbbbeeiiffbbbbbbbbbbbbbbbbeeiffbbbbbccccddddeeeeeeeffffff",
                    "bbfffiiiiabbbabbfffieeaaaabaaaffieeeabcabbacfffieccccccccbbbbbbbbbcccccbbbbeeiiffbbbbbbbbbbcbbbbbeeiffbbbbcccddddddeeeeeeeffffff",
                    "bbffieeeebaababbfffieeabaabaaaffieeeabcabcacfffiedddcccccccccccccbbbbbccbbbeeiiffbbbbbbbbbbbbbbbbeeiffbbcccdddddddceeeeeeeffffff",
                    "bbffieeeeeaaaaaafffieeaababaaaffieeeaaaaccacfffieddddddccccccccccccccccccbbieeiffbbbbbbbbbbbbbbbbeeiffccccdddddddcceeeeeeeffffff",
                    "bfffieeeeeaaaaaafffieeaababaaaffieeeaaaaaaacfffiedddddddddccccccccccccccccceiifffbbbbbbbbbbbbbbbbeeiffcccdddddddccbffeeeeeffffff",
                    "bfffiieeeeaaaaaafffieeaababaaaffieeeaaaaccacfffieddddddddddddddcccccccccccceeeifbbbbbbbbbbbbbbccceefffccdddddddccbhhhfieeeffffff",
                    "bffffieeeeaaaaaafffieeaaaaaaaaffieeeaaaaacacffffiddddddddddddddddddddddddddeeeiffbbbbbbbbbbcccccdeeiffddddddddccbbhhhffiifffffff",
                    "bffffiieeeaaaaaafffieeaaaaaaaaffieeeaababaaafffieccddddddddddddddddddddddddeeiiffcccccccccccccdddeeiffdddddddccbbhhhhffieeffffff",
                    "bffffiieeeaaaaaafffieeaaaaaaaaffieeeaababbabfffiecccdddfiedddddddddddddddddeeiifdccccddddddddddddeeiffdddddcccbbbhhhffiieeffffff",
                    "bffffiieeiaaaaaafffieeaaaaaaaafffiiiaaaabbabfffieccccddfiedddddddddddddddddeeeifdddddddddddddddddeeiffddddccbbbbbhhhffiieeffffff",
                    "bffffiieeiaababafffieeabaaaaaaffeeeeaaaaaaabfffiebcccccfiecdddddddddddddccceeeifdddddddddddddddddieiffdddccbbbbbhhhfffeeeeffffff",
                    "bbfffiieeiaababafffieeababaaaaffeieeaaaaaaaafffiebbbcccfiecccccddcccccccccceeeifdddddddadddddddddieiffdcccbbbbbbhhhffieeeeffffff",
                    "bbffiiieeiaaaaaafffieeababaaaaffeieeaaaaaaaafffiebbbbbcfiicccccccccccccccccieiifccdddddadcdccccccieiffccbbbbbbbbhhhffieeeeffffff",
                    "bbffiiiieeaababafffiieababaaaaffeiieaaaaaaaafffiebbbbbbfiebbcccccccccccccbbeifffcccccccacccccccccieiffbbbbbbbbbhhhfffeeeeeffffff",
                    "bfffiiiieeaababafffiieababaaaaffiiieaaaaaaaafffieababbbfiebbbbbbbbbbbbbbbbbeeiifcccbbbabbbbbcccccieiffbbbbdbbbbhhhffeeeeeeffffff",
                    "bfffiiiieeaaaabaffffiiababaaaaffiiieababaaaafffieaaabbbfiebbbbbbbbbbbbbbbbbeeiifbbbbbbaaabbbbbbbbeeiffbbgbbbbbhhhfffeeeeeeffffff",
                    "ffffiiieeaaaaaafffiieababbaaaaffiiieababaabaffffeaaabbbfiebbbbbbbbbbgbdbbbbeeiifbbbifabbabbbbbbbbeeiffbbbbbbbbhhhffieeeeeeffffff",
                    "ffffiiiieaaaaaafffieeababaaaaffiiiiababaabafffieababbbfiibbbbbbbbbbbbbbbbbeeiifbbiiffbbabbbbbbbbbeeiffbbbbbbbhhhhffieeeeeefffffa",
                    "fffiiiiiiabaabafffieeaaaaaaaafffiiiababaabafffieabaaabfiebbbgbbiifbbbbbbbbeiiifbbiiffbbabbbbbabaeeiffbbbbbbbbhhhfffieeeeeefffffa",
                    "fffiiiiiiabaabafffieeababaaaaffiiiiaaaaaabafffieabababfiebbbbbbiiffibbbbbbeiiifbbiiffbbaaaaaaaaaeeiffbbbbbbahhhffieeeeeeeffffffa",
                    "fffiiiieeabaabafffieeababaaaaffiiiiabaaaaaafffieababbbfiebbbbbbiiffiibiifbeiiifbbiiffbbabbbbabbaeeiffbbbbbahhhhffieeeeeeefffffaa",
                    "fffiiiiiiibafeafffiieababaaaaffiiiiabafeaaafffieababbbfiebbbdbbiifffifiifbiiiifbbiiffbbabbbbabbaeiiffbbbbbahhhfffieeeeeeefffffaa",
                    "fffiiiiiiiaafeefffiieababaaaeffffiiabaiefaafffieaahbbbfiebbbbbbiifbbbbiifbeeiffbbiiffbbabdbbabbaeeiffbbbbahhhhffiieeeeeeefffffaa",
                    "fffiiiiiiiaafeefffiieababaaaeefiiiiaaieifaafffieahhbbbfiibbbbbbiifbbbbiifbeeeifbbiiffababbbbabbaeiiffbbbaahhhfffieeeeeeeefffffaa",
                    "fffiiiiiiiaafeefffiieaaaaaaieifiiiiaaiefaaafffiiaffaabfiebbbbbbiifbbbbiifbiiiifbbiiffaaabaababbaiiiffbaaaaffffffieeeeeeeefffffaa",
                    "fffiiiiiiiaafeefffiiiaaaaafieifiiiiafeifeaafffiiaffaaafiibbabbaiifabaaiifbiiiifabiiffaaaaahaabbaiiiffaaaaeeeeffiieeeeeeeefffffaa",
                    "fffiiiiiiiaafeefffiiiaaaaffeiffiiiiafeifieafffiiaafiaafiiababaaiifaaaaiifbiiiifaaiiffaaaahhfaaaaiiiffaaaaeeefffiieeeeeeiefffffaa",
                    "fffiiiiiiifafeifffiiiaffffeeiefiiiifiiffiiafffiiaaffaafiiaaaaaaiifaaeffifbiiiifaaiiffaaaahiffaaaiiiffaaaeeeeffieieeeeeeiefffffaa",
                    "iifiiiiiiifefeifffiihafeffieieffffffifeefiifffiiaaaffafiiaaaaaaiifaeiffifbiiiifaaiiffeiahhiffaaaiiiffaaaeeefffieeeeeeeeiefffffaa",
                    "fffffffffffefifffffhhhfiefiiiffeeeefifefffiffeeeeiaffffiifaffaififeifeeffbiiiffaaiifeeiahhffafaaiiiffaaeeeefffieeeeeeeeiefffffaa",
                    "fffeeeeeeeeieffiifffhhhfieifeffiiiiffffeiffifiiiiiffeeffeffffiifffiifiififffifffaifefffihfffafaaiiiffaaeeefffiieeeeeeeeiifffffaa",
                    "iifffiiiiiiiieffffffhhhfiiefefffffffiefiififeeffieefiiiefeiiifffiieeefffffeefffaafiifffiiffffffafffffafieefffiiieeeieeeiiffffaaa",
                    "iieeeeifiiiffifffffffhhhfiefffeeiiiieeeffiifiifefiefffiifffiiiiiifiiffifiiiieiffaafffefhhhhhfiffeeeifafiiifffeeieiiieeiiiffffaaa",
                    "ffiiiiifiiffeefffffffhhhhffjjfffieeffffffffffffffffiieeeeiiiieeiiiffifieeifiiiffiifeffhhhhhfffifiiiiffiiifffieeiiiiiieiifffaafaa",
                    "ffffffffiffiiiifffffffhhhfefjjjjfffiiiiiiijjjjjjjjjjiiiiifjjjiiiiiiiffffffffeeeeifffffhhhhfffffeeiifffiiifffieiiiiiiiiiiaafaaaaa",
                    "iiiffffffifiifeeffffffhffkkkkkkkjjjjjjjjjjjeejjjjjjjiiiiifjjjkkkkkkjjjjiiiijfffffffffhhhhhfffffffiiifiiiiffiiiiiiiiiiiiiiaaaaaaa",
                    "fffiiffffffifiiffffffffjjjkllfflkfefjjjjfjjjjjjjjjjjffffffjjjjkllllkjjjjjjjjjjjjiiiifhhhhfffffffffifiiiifffiiiiiifiiiiiiiaaaaaaa",
                    "ffefffffffffffffffffjjjjjjklfeefkeiffjfefjjjjjfeeefjjjjjjjjjjjjkkkkkkeeejjjfjjeejjjfhhhhhffffffffffffiiifffiiiiiifiiiiiiaaaaaaaa",
                    "fffeffjjiijjjjjjjjjjjjjjjjfeeefkkffefiifjjjjjfiiifjjjjjjjjjjeejjjjjjjjjjfeejjjjjjifhhhhffffffffffffiiifffiiaiiifffiiiiiiaaaaaaa",
                    "fffeffjjjjjjjfeeeeeeeeeeeejfffffjjjffffffffjjjfffffjjjjjjeeeejjjjjjjjjjjjjfffjjjjjjjfffifffffffffffiiiifffiaaffffaaaiiiiiaaaaaaa",
                    "ffiiijjjjjjjeeeeeeeeeeeeeefjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjhhhjjjjjjjjfiijjjjjjjiffffffhhhhhffiiiffaaaaaafaaaaaiiiiaaaaaaa",
                    "fhfeefjeeiiffffffffffffffhfjjfefjjjjjjjmmmmmmmjjjjjjjjjjjjjjjjjjhhhffjjjjjjjjjjjjjjjjjjjjjfhhhhhifhfiifffaaaaaaaaaaaaiiiaaaaaaa",
                    "jifiifjfjjjffffffffffffffhfjifffijjjjjmmnnnnmjjjjffjjfeefjjjjjfihffffjiiiijjjjjjjjjjjjjjjhiiiiiifffifffffaaaafaaaaaaaffaaaaaaaa",
                    "jjfffjjjffjffffffffffffffhfjjjjjjjjjjmmmmnnmjjjjjjjfffiifjjjjjfifffffjjjjiiejfffjoooooojjjffffffffiifiifffaaffaaaaaaaaaaaaaaaaaa",
                    "ffjjjjjjfjjffffffffffffffffjjjjjjjjjmmmmmmmjjjjjjjjjjffffjjjjjjfffffffjjjjiiejjjjjoppppojjffffffffififfiiifaaaaaaaaaaaaaaaaaaaaa",
                    "ffjjjjffffffffffffffffffffjjjjjjjjjeeejjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjiijjjjjjoppppojjjjjfhhffffiifffffaaaaaaaaaaaaaaaaaaaa",
                    "jjjjfffhhhhhffffffffffffffjjjjjfffjjjjjjjjjjjjjjjjjjjjjjjjjjfeeeeefjjjjjjjjjeeeejjjjoooooofhhfhiififfffiifffffaaaaaaaaaaaaaaaaaa",
                    "fffffffffhhhhffffffffffjjjjejjfffffjjjjjjjiiiiijjjjjjjjjjjjjfiiiiifjjjjjjjjjiiiiiijjjfjjjjfiiffffffffffffffffffaaaaaaaaaaaaaaaaa",
                    "ffffffffffhhhhhffjjjjjjjjjjffffffffjjjjjjfiifjjjjjjjjjjjjjjjffffffjjjjjjjjjjjjjjjjjfffjjjjfffffhhfjfhhfffffffffaaaaaaaaaaaaaaaa",
                    "fffffffffffhhhhhfjjjjjjfffffffffffffjjjjjffffjjjjeejjjjjjjjjjjjjjjjjjjjjjjjiiiijjjjfffffjjjjjjjjffjjjfffffffffffaaaaaaaaaaaaaaaa",
                    "aaffffffffffhhhhhfjjjjfeefffffffffffjjjiiffffjjeejjeeejjjjjjjjjjjjjjjjjjjjjjjjjjjjfffffffjjjjjjjjjjjjjjjahhffffaaaaaaaaaaaaaaaaa",
                    "aaaaaaaaaaaaaaaaaaaaaaaaaafffffffffffjjjjjjjjjjjjjjjjjeeeeeeejjjjjjjjeeeeeejjjjjjjffffffffjjjjjjjiihjjjaaaahaaaaaaaaaaaaaaaaaaaa",
                    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaajjjjjjjjjjjjjjjjjjffffffeeeeeeffffffffffiifffffffhfaaaaaaaaaaaaaaaaaaaaaaaaaa",
                ],
            };

            const Title = {
                palette: {
                    " ": [255,0,0,0],
                    "a": [61,8,11,255],
                    "b": [20,71,10,255],
                    "c": [9,19,71,255],
                    "d": [148,18,27,255],
                    "e": [33,125,15,255],
                    "f": [16,31,110,255],
                },
                data: [
                    "aaaaaaaaa bbbbbbbbb ccccccccc aaaaaaaaa bbbbbbbbb ccccccccc aaaaaaaaa",
                    "addddddda beeeeeeeb cfffffffc addddddda beeeeeeeb cfffffffc addddddda",
                    "adaadaada bbebbbbeb cfcccccfc adaaaaada bbebbbbeb cfcccccfc adaaaaada",
                    "addadadda  beb  bbb cfc cfcfc ada adada  beb  bbb cfc   cfc ada   ada",
                    "aaaadaaaa  beb      cfc cfffc ada addda  beb      cfcc  cfc adaa  ada",
                    "   ada     beb      cfc ccccc adaaaaaaa  beb      cfcccccfc adaaaaada",
                    "   ada     bebbbb   cfccccccc addaaaaa   bebbbb   cfffffffc addddddda",
                    "   ada     beeeeb   cfffffffc aadddddaa  beeeeb   cfcfffccc adaaaaada",
                    "   ada     bebbbb   cccccccfc  aaaaadda  bebbbb   cfcccffc  ada   ada",
                    "   ada     beb      ccccc cfc aaaaaaada  beb      cfcccffc  ada   ada",
                    "   ada     beb      cfffc cfc addda ada  beb      cfc ccfc  ada   ada",
                    "   ada     beb  bbb cfcfc cfc adada ada  beb  bbb cfc  cfc  ada   ada",
                    "  aadaa   bbebbbbeb cfcccccfc adaaaaada bbebbbbeb cfcc cfcc adaa aada",
                    "  addda   beeeeeeeb cfffffffc addddddda beeeeeeeb cffc cffc adda adda",
                    "  aaaaa   bbbbbbbbb ccccccccc aaaaaaaaa bbbbbbbbb cccc cccc aaaa aaaa",
                ],
            };

            
            
            
            let bgSprite = null;   
            let titleSprite = null;   
            let ready = false;

            
            let _clicked = false;

            
            const stars = [];

            function initStars(count = 80) {
                for (let i = 0; i < count; i++) {
                    stars.push({
                        x: Math.random(),        
                        y: Math.random(),
                        r: 0.4 + Math.random() * 1.4,
                        speed: 0.00008 + Math.random() * 0.00018,
                        phase: Math.random() * Math.PI * 2,
                        opacity: 0.3 + Math.random() * 0.7,
                    });
                }
            }

            
            
            
            return {
                
                init() {
                    bgSprite  = bakeSprite(Background.data, Background.palette);
                    titleSprite = bakeSprite(Title.data, Title.palette);
                    initStars();
                    ready = true;

                    
                    const onInput = () => { _clicked = true; };
                    window.addEventListener("mousedown", onInput, { once: true });
                    window.addEventListener("touchstart", onInput, { once: true });
                },

                
                onClick() { return _clicked; },

                
                draw(ctx, w, h, t) {
                    if (!ready) return;

                    ctx.fillStyle = "rgb(5, 5, 20)";
                    ctx.fillRect(0, 0, w, h);

                    
                    for (const s of stars) {
                        const pulse = 0.5 + 0.5 * Math.sin(t * 1.8 + s.phase);
                        ctx.save();
                        ctx.globalAlpha = s.opacity * (0.5 + 0.5 * pulse);
                        ctx.fillStyle   = "#d8e8ff";
                        ctx.beginPath();
                        ctx.arc(s.x * w, s.y * h, s.r, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    }

                    
                    const bgW  = Math.round(w * 0.95);
                    const bgH  = Math.round(bgW * (bgSprite.height / bgSprite.width));
                    const bgX  = Math.round((w - bgW) / 2);
                    const bgY  = Math.round((h - bgH) / 2);

                    ctx.save();
                    ctx.imageSmoothingEnabled = false;
                    ctx.drawImage(bgSprite, bgX, bgY, bgW, bgH);
                    ctx.restore();

                    
                    const vig = ctx.createRadialGradient(w/2, h/2, h*0.15, w/2, h/2, h*0.75);
                    vig.addColorStop(0, "rgba(0,0,0,0)");
                    vig.addColorStop(1, "rgba(0,0,0,0.65)");
                    ctx.fillStyle = vig;
                    ctx.fillRect(0, 0, w, h);

                    
                    const titleW = Math.round(w * 0.42);
                    const titleH = Math.round(titleW * (titleSprite.height / titleSprite.width));
                    const titleX = Math.round((w - titleW) / 2);
                    
                    const floatY = Math.round(h * 0.06 + Math.sin(t * 0.9) * 4);
                    const titleY = Math.round(h * 0.12 + floatY);

                    
                    ctx.save();
                    ctx.imageSmoothingEnabled = false;
                    ctx.shadowColor = "rgba(0,0,0,0.85)";
                    ctx.shadowBlur = 18;
                    ctx.shadowOffsetY = 6;
                    ctx.drawImage(titleSprite, titleX, titleY, titleW, titleH);
                    ctx.restore();


                },

                t: 0,
            };
        })();
    </script>
    <script type>
        // since setInterval is so slow, this replaces Date.now and someother nasty stuff to make a nice reusable group of functions. I recieved a lot of help from the internet making this, and by no means is it the best implementation, but it does the trick
        (() => {
            /** 
                Created by Arrow
                https://www.khanacademy.org/profile/Arrow.programming
            **/
            //performance.now() is faster than Date.now()
            if (typeof performance === 'undefined' || !performance.now) {
                //fallback
                globalThis.performance = globalThis.performance || { 
                    now: () => Date.now() 
                };
            }
            
            //MessageChannel microtask-style scheduler for near-zero delays (faster than setTimeout(0))
            const mc = typeof MessageChannel !== 'undefined' ? new MessageChannel() : null;
            const _immediateQueue = new Map();
            let _immediateId = 1;
            if (mc) {
                mc.port1.onmessage = (e) => {
                    const id = e.data;
                    const fn = _immediateQueue.get(id);
                    if (fn) {
                        _immediateQueue.delete(id);
                        try { 
                            fn(); 
                        } catch (err) { 
                            setTimeout(() => { 
                                throw err; 
                            }, 0); 
                        }
                    }
                };
            }
            function postImmediate(fn) {
                if (!mc) {
                    //no MessageChannel available fallback
                    return setTimeout(fn, 0);
                }
                const id = _immediateId++;
                _immediateQueue.set(id, fn);
                mc.port2.postMessage(id);
                return id;
            }
            
            //internal registry so we can clear by id like clearInterval
            const timers = new Map();
            let nextTimerId = 1;
            
            //setFastInterval: returns numeric id (like setInterval). Use clearFastInterval(id) to stop.
            function setFastInterval(fn, intervalMs, options = {}) {
                if (typeof fn !== 'function'){ 
                    throw new TypeError('callback must be a function');
                }
                intervalMs = Number(intervalMs) || 0;
                
                const id = nextTimerId++;
                let expected = performance.now() + intervalMs;
                let stopped = false;
                let pendingHandle = null;
                
                //not the best implementation, but oh well lol
                function scheduleNext(delay) {
                    if (stopped){ 
                        return;
                    }
                    if (delay <= 1) {
                        //near-zero delay 
                        pendingHandle = postImmediate(step);
                        timers.set(id, { stop: () => { 
                            /* cannot cancel MessageChannel post; leave fn guard */ 
                            
                        } });
                    } 
                    else {
                        pendingHandle = setTimeout(step, delay);
                        timers.set(id, { 
                            stop: () => clearTimeout(pendingHandle) 
                        });
                    }
                }
            
                function step() {
                    if (stopped) {
                        return;
                    }
                    
                    const now = performance.now();
                    const drift = now - expected;
                    
                    //run callback again :P
                    try { 
                        fn(); 
                    } 
                    catch (err) {
                        //Don't break the timer on user errors lol
                        setTimeout(() => { throw err; }, 0);
                    }
                    
                    //compute next expected time and the delay to schedule
                    expected += intervalMs;
                    
                    //If the drift is huge (like tab is suspended in chrome or edge i think edge has that?), skip missed intervals by catching up
                    if (drift > intervalMs * 5) {
                        //If drift is extremely large, reset expected to now + interval to avoid long backlog loops
                        expected = now + intervalMs;
                    }
                    
                    const nextDelay = Math.max(0, intervalMs - Math.max(0, drift));
                    scheduleNext(nextDelay);
                }
                    
                //intiaite
                scheduleNext(intervalMs);
                    
                timers.set(id, {
                    stop: () => {
                        stopped = true;
                    
                        //cleanup for pending handle if it's a timeout
                        try { 
                            clearTimeout(pendingHandle); 
                        } catch (_) {}
                    
                        _immediateQueue.forEach((fn, k) => {
                            if (fn === step) { 
                                _immediateQueue.delete(k);
                            }
                        });
                        
                        timers.delete(id);
                    }
                });
                    
                return id;
            }
            
            function clearFastInterval(id) {
                const t = timers.get(id);
                if (!t) {
                    return; 
                }
                t.stop();
            }
                
            //make this global
            if (typeof globalThis !== 'undefined') {
                globalThis.setFastInterval = setFastInterval;
                globalThis.clearFastInterval = clearFastInterval;
            } 
            else if (typeof window !== 'undefined') {
                window.setFastInterval = setFastInterval;
                window.clearFastInterval = clearFastInterval;
            } 
            else if (typeof self !== 'undefined') {
                self.setFastInterval = setFastInterval;
                self.clearFastInterval = clearFastInterval;
            } 
            else {
                //and export!
                try { 
                    module.exports = { 
                        setFastInterval, 
                        clearFastInterval 
                    }; 
                } catch (_) {}
            } 
        })();
    </script>
    <script type>
        (function Application() {
            let inTutorial = true;

            const pixelArtColors = ["#D1A593", "#6BCB77", "#45B7D1", "#271232"];
            
            const storedDataString = storage.getItem("axh-coc-round-3--data");
            let storedData = JSON.parse(storedDataString) ?? Object.create(null);

            class Intro {
                constructor() {
                    this.prog = 0;
                    this.spdLns = [];
                    this.arrowX = width / 2;
                    this.textFade = 0;
                }
                run() {
                    document.getElementById("interface").style.display = "none";
                    ctx.lineJoin = "round";
                    this.prog++;
                    ctx.fillStyle = "rgba(18, 18, 18, 1)"
                    ctx.fillRect(0, 0, width, height)
                    if (this.prog < 200) {
                        this.spdLns.push({
                            x: width / 2 + random(-150, 150),
                            y: -25,
                            sz: 50
                        });
                        for (var i = 0; i < 3; i++) {
                            var b = random(random(random(-70, 0), 0), random(0, random(0, 70)));
                            this.spdLns.push({
                                x: width / 2 + b,
                                y: height / 2 + Math.abs(b),
                                sz: 40
                            });
                        }
                    } else if (this.prog > 200 && this.prog < 250) {
                        this.arrowX = lerp(this.arrowX, width / 2 - 80, 0.1);
                    } else if (this.prog > 250 && this.prog < 320) {
                        this.textFade = lerp(this.textFade, 255, 0.05);
                    } else if (this.prog > 360) {
                        //replace transition code as needed :)
                        window.scene = "menu";
                        MenuScreen.init();
                    }

                    for (var i = 0; i < this.spdLns.length; i++) {
                        var a = this.spdLns[i];
                        ctx.fillStyle = "rgba(245, 245, 245, 1)"
                        ellipse(a.x, a.y, 1, a.sz);
                        a.y += 16.7;
                        if (a.y > height + 25) {
                            this.spdLns.splice(i, 1);
                        }
                    }
                    ctx.save();
                    ctx.translate(this.arrowX, height / 2);
                    ctx.lineWidth = 5;
                    ctx.strokeStyle = `rgba(255, 255, 255, ${this.textFade/255})`;
                    ctx.fillStyle = `rgba(255, 255, 255, ${1 - this.textFade/255})`;
                    ctx.beginPath();
                    ctx.lineTo(-50, 50);
                    ctx.bezierCurveTo(-31, -16, -8, -44, 0, -54);
                    ctx.bezierCurveTo(18, -37, 34, 1, 50, 51);
                    ctx.bezierCurveTo(25, 13, 7, -3, 0, -9);
                    ctx.bezierCurveTo(-17, 6, -44, 42, -50, 51);
                    ctx.stroke();
                    ctx.fill();
                    ctx.closePath();

                    ctx.save();
                    ctx.translate(-100, -200);

                    ctx.beginPath();
                    ctx.lineTo(161, 237);
                    ctx.bezierCurveTo(162, 211, 162, 207, 159, 203);
                    ctx.lineTo(161, 208);
                    ctx.bezierCurveTo(166, 201, 170, 200, 176, 208);
                    ctx.stroke();
                    ctx.closePath();


                    ctx.beginPath();
                    ctx.lineTo(190, 238);
                    ctx.bezierCurveTo(191, 210, 191, 210, 188, 202);
                    ctx.lineTo(192, 206);
                    ctx.bezierCurveTo(196, 203, 200, 201, 207, 211);
                    ctx.stroke();
                    ctx.closePath();


                    ctx.beginPath();
                    ctx.lineTo(224, 206);
                    ctx.bezierCurveTo(210, 213, 210, 225, 224, 234);
                    ctx.bezierCurveTo(241, 224, 237, 210, 223, 206);
                    ctx.stroke();
                    ctx.closePath();


                    ctx.beginPath();
                    ctx.lineTo(247, 204);
                    ctx.bezierCurveTo(260, 241, 260, 241, 270, 208);
                    ctx.bezierCurveTo(279, 241, 279, 241, 293, 204);
                    ctx.stroke();
                    ctx.closePath();


                    ctx.beginPath();
                    ctx.lineTo(136, 168);
                    ctx.bezierCurveTo(140, 171, 150, 169, 154, 171);
                    ctx.stroke();
                    ctx.closePath();


                    ctx.beginPath();
                    ctx.lineTo(142, 158);
                    ctx.bezierCurveTo(143, 168, 143, 178, 145, 191);
                    ctx.stroke();
                    ctx.closePath();


                    ctx.beginPath();
                    ctx.lineTo(158, 176);
                    ctx.bezierCurveTo(165, 178, 173, 178, 181, 177);
                    ctx.bezierCurveTo(170, 159, 168, 159, 157, 177);
                    ctx.bezierCurveTo(168, 192, 168, 192, 179, 184);
                    ctx.stroke();
                    ctx.closePath();

                    ctx.beginPath();
                    ctx.lineTo(213, 188);
                    ctx.bezierCurveTo(208, 183, 212, 165, 199, 168);
                    ctx.bezierCurveTo(186, 169, 187, 189, 195, 190);
                    ctx.bezierCurveTo(202, 193, 206, 185, 207, 182);
                    ctx.stroke();
                    ctx.closePath();


                    ctx.beginPath();
                    ctx.lineTo(223, 191);
                    ctx.bezierCurveTo(230, 159, 230, 159, 238, 192);
                    ctx.bezierCurveTo(250, 160, 250, 160, 257, 191);
                    ctx.stroke();
                    ctx.closePath();
                    ctx.restore();
                    ctx.restore();

                    ctx.lineJoin = "miter";
                }
            }
            let intro = new Intro();



            let roundError = 1;

            //this.drones
            let debugMode = !true;




            window.scene = "intro";

            /**
             * Convert DOM screen coordinates to canvas (world) coordinates taking CSS
             * layout into account.
             * @param {number} screenX - Client X coordinate from mouse event.
             * @param {number} screenY - Client Y coordinate from mouse event.
             * @returns {{x:number,y:number}} Coordinates in canvas space.
             */

            function screenToWorld(screenX, screenY) {
                //get canvas position and dimensions
                const rect = canvas.getBoundingClientRect();

                //convert screen coords to canvas coords
                const canvasX = screenX - rect.left;
                const canvasY = screenY - rect.top;

                return {
                    x: canvasX,
                    y: canvasY
                };
            }

            //the game
            const Application = (function() {
                const App = function(config) {
                    //self represent
                    this.app = App;

                    /**
                     * Represents a single tile in the grid. Stores visual state and
                     * provides simple update/draw helpers for smooth animation.
                     */
                    class Tile {
                        /**
                         * Create a Tile instance.
                         * @param {number} col - Column index on the board.
                         * @param {number} row - Row index on the board.
                         * @param {number} [colorIndex=0] - Index into `tileColors` for visual color.
                         * @param {Object} sides - Indicators on sides of Tile instance.
                         */
                        constructor(col, row, colorIndex = 0, sides) {
                            this.col = col;
                            this.row = row;
                            //0 or 1 blue or green
                            this.colorIndex = colorIndex;
                            this.x = 0;
                            this.y = 0;
                            this.targetX = 0;
                            this.targetY = 0;
                            this.matched = false;
                            this.isMoving = false;
                            this.scale = 1;
                            this.rotation = 0;
                            this.opacity = 1;
                            this.falling = false;
                            this.beingDragged = false;

                            //side indicators
                            this.sides = sides ?? {
                                left: false,
                                right: false,
                                up: false,
                                down: false
                            };
                            // randomize
                            if (!sides) {
                                const sidesArr = ["left", "right", "up", "down"];
                                let count = Math.floor(Math.random() * 4) + 1;
                                while (count > 0) {
                                    const i = Math.floor(Math.random() * sidesArr.length);
                                    const s = sidesArr.splice(i, 1)[0];
                                    this.sides[s] = true;
                                    count--;
                                }
                            }
                        }

                        /**
                         * Calculate and update the tile's target position based on grid coordinates.
                         * If the tile is not currently moving, snap its displayed position to the target.
                         * @param {number} tileSize
                         * @param {number} boardX
                         * @param {number} boardY
                         * @returns {void}
                         */
                        updatePosition(tileSize, boardX, boardY) {
                            this.targetX = boardX + this.col * tileSize + tileSize / 2;
                            this.targetY = boardY + this.row * tileSize + tileSize / 2;

                            if (!this.isMoving) {
                                this.x = this.targetX;
                                this.y = this.targetY;
                            }
                        }

                        /**
                         * Progress the tile's animation toward its target position and
                         * update visual properties such as `scale` and `opacity`.
                         * @param {number} dt - Delta time in seconds since last frame.
                         * @returns {void}
                         */
                        animate(dt) {
                            //dont animate while user is dragging this tile
                            if (this.beingDragged) return;

                            //move with predictable per-axis speed to avoid jerk
                            const maxSpeedY = 1200;
                            const maxSpeedX = 1000;

                            const dy = this.targetY - this.y;
                            const dx = this.targetX - this.x;

                            const stepY = Math.sign(dy) * Math.min(Math.abs(dy), maxSpeedY * dt);
                            const stepX = Math.sign(dx) * Math.min(Math.abs(dx), maxSpeedX * dt);

                            this.x += stepX;
                            this.y += stepY;

                            const dist = Math.hypot(dx - stepX, dy - stepY);
                            const stopThreshold = Math.max(0.5, 8 * dt);
                            if (Math.abs(dx) <= stopThreshold && Math.abs(dy) <= stopThreshold) {
                                this.x = this.targetX;
                                this.y = this.targetY;
                                this.isMoving = false;
                            } else {
                                this.isMoving = true;
                            }

                            //smooth scale back to 1
                            if (this.scale > 1) {
                                const scaleSpeed = 6;
                                const delta = (1 - this.scale) * (1 - Math.exp(-scaleSpeed * dt));
                                this.scale += delta;
                                if (this.scale < 1.01) this.scale = 1;
                            }

                            // if (this.matched) {
                            //     this.scale *= 0.95;
                            //     this.opacity *= 0.9;
                            // }
                        }

                        /**
                         * Render the tile to the global `ctx` canvas context.
                         * @param {number} tileSize - Size used for drawing calculations.
                         * @param {boolean} [isDragging=false] - Whether the tile is currently being dragged (affects styling).
                         * @param {boolean} [grayed=false] - Whether the tile is grayed.
                         * @returns {void}
                         */
                        // draw(tileSize, isDragging = false) {
                        //     ctx.globalAlpha = this.opacity;
                        //     ctx.save();
                        //     ctx.translate(this.x, this.y);
                        //     ctx.scale(this.scale, this.scale); 
                        //     ctx.rotate(this.rotation);

                        //     const cornerRadius = 8; 
                        //     const bgSize = tileSize * 0.48;
                        //     const fillColor = tileColors[this.colorIndex % tileColors.length];
                        //     //background rounded rect
                        //     ctx.fillStyle = fillColor;
                        //     ctx.beginPath();
                        //     ctx.moveTo(-bgSize + cornerRadius, -bgSize);
                        //     ctx.lineTo(bgSize - cornerRadius, -bgSize);
                        //     ctx.quadraticCurveTo(bgSize, -bgSize, bgSize, -bgSize + cornerRadius);
                        //     ctx.lineTo(bgSize, bgSize - cornerRadius);
                        //     ctx.quadraticCurveTo(bgSize, bgSize, bgSize - cornerRadius, bgSize);
                        //     ctx.lineTo(-bgSize + cornerRadius, bgSize);
                        //     ctx.quadraticCurveTo(-bgSize, bgSize, -bgSize, bgSize - cornerRadius);
                        //     ctx.lineTo(-bgSize, -bgSize + cornerRadius);
                        //     ctx.quadraticCurveTo(-bgSize, -bgSize, -bgSize + cornerRadius, -bgSize);
                        //     ctx.closePath();
                        //     ctx.fill();

                        //     ctx.strokeStyle = isDragging ? "rgba(255,255,180,0.9)" : "rgba(255,255,255,0.6)";
                        //     ctx.lineWidth = isDragging ? 3 : 2;
                        //     ctx.stroke();

                        //     //draw small red indicators on sides
                        //     ctx.fillStyle = "#D9534F";
                        //     const indLen = tileSize * 0.22;
                        //     const indW = Math.max(3, Math.round(tileSize * 0.06));
                        //     if (this.sides.up) {
                        //         ctx.fillRect(-indLen / 2, -bgSize + 6, indLen, indW);
                        //     }
                        //     if (this.sides.down) {
                        //         ctx.fillRect(-indLen / 2, bgSize - 6 - indW, indLen, indW);
                        //     }
                        //     if (this.sides.left) {
                        //         ctx.fillRect(-bgSize + 6, -indLen / 2, indW, indLen);
                        //     }
                        //     if (this.sides.right) {
                        //         ctx.fillRect(bgSize - 6 - indW, -indLen / 2, indW, indLen);
                        //     }

                        //     ctx.restore();
                        //     ctx.globalAlpha = 1;
                        // }
                        draw(tileSize, isDragging = false, grayed = false) {
                            PixelArt.draw(
                                ctx,
                                this.colorIndex,
                                this.sides,
                                this.x, this.y,
                                tileSize,
                                this.opacity,
                                this.scale,
                                isDragging,
                                grayed
                            );
                        }
                    }

                    /**
                     * Small left-side pool of tiles (spare tiles). Manages positions for
                     * pooled tiles and supports dragging from the pool.
                     */
                    class TilePool {
                        /**
                         * Create a TilePool to hold spare tiles displayed beside the board.
                         * @param {number} tileSize
                         * @param {number} [left=10]
                         * @param {number} [top=10]
                         * @param {Object} [parent=null] - Reference to parent TileBoard for board coordinates and right grid.
                         */
                        constructor(tileSize, left = 10, top = 10, parent = null, poolWidth = 400) {
                            this.tileSize = tileSize; 
                            this.left = left;
                            this.top = top;
                            this.poolWidth = poolWidth;
                            this.padding = 22;
                            this.spacing = 10;
                            this.tiles = [];
                            this.selectedTile = null;
                            this.draggedTile = null;
                            this.draggedTileOriginal = null;
                            this.dragOffsetX = 0;
                            this.dragOffsetY = 0;
                            this.invalidDrop = false;
                            this.invalidDropTile = null;
                            this.invalidDropTime = 0;
                            this.parent = parent;
                            if (storedData.pool) {
                                for (const i in storedData.pool) {
                                    const tileData = storedData.pool[i];
                                    const { colorIndex, sides } = tileData;
                                    const tile = new Tile(0, 0, colorIndex, sides);
                                    const { x, y } = this.getTarget(i, storedData.pool.length);
                                    tile.x = x;
                                    tile.y = y;
                                    this.tiles.push(tile);
                                }
                            }
                        }

                        /**
                         * Compute the drawing target position for a pooled slot index.
                         * @param {number} slot
                         * @returns {{x:number,y:number}}
                         */
                        getTarget(slot, total = null) {
                            const count = total !== null ? total : this.tiles.length;

                            //distance between first and last tile center
                            const usable = this.poolWidth - this.tileSize;

                            //evenly divide this always keeps groupWidth === poolWidth exactly
                            const spacing = count > 1 ? usable / (count - 1) : 0;

                            //group is always poolWidth wide so centering is just left + tileSize/2
                            const startX = this.left + this.tileSize / 2;

                            return {
                                x: startX + slot * spacing,
                                y: this.top + this.tileSize / 2
                            };
                        }

                        /**
                         * Add a tile to the end of the pool and position it.
                         * @param {Tile} tile
                         * @returns {void}
                         */
                        add(tile) {
                            const slot = this.tiles.length;
                            const newTotal = slot + 1;

                            tile.poolIndex = slot;
                            tile.inPool = true;
                            tile.toBePooled = false;
                            tile.toBeDeleted = false;
                            tile.beingDragged = false;
                            tile.matched = false;
                            tile.scale = 1;
                            tile.opacity = 1;
                            tile.rotation = 0;

                            this.tiles.push(tile);

                            //reposition every tile including the one just pushed
                            for (let i = 0; i < this.tiles.length; i++) {
                                const p = this.tiles[i];
                                const t = this.getTarget(i, newTotal);
                                p.targetX = t.x;
                                p.targetY = t.y;
                                if (i < this.tiles.length - 1) {
                                    //existing tiles animate to their new spread positions
                                    p.isMoving = true;
                                } 
                                else {
                                    //only animate if it's not already there
                                    const dx = Math.abs(p.x - t.x);
                                    const dy = Math.abs(p.y - t.y);
                                    if (dx > 1 || dy > 1) {
                                        p.isMoving = true;
                                    } else {
                                        p.x = t.x;
                                        p.y = t.y;
                                        p.isMoving = false;
                                    }
                                }
                            }
                        }

                        /**
                         * Insert a tile at the specified pool index, shifting others.
                         * @param {Tile} tile
                         * @param {number} idx
                         * @returns {void}
                         */
                        insertAt(tile, idx) {
                            //insert back into pool at index and renumber
                            this.tiles.splice(idx, 0, tile);
                            for (let i = 0; i < this.tiles.length; i++) {
                                const p = this.tiles[i];
                                p.poolIndex = i;
                                const t = this.getTarget(i);
                                p.targetX = t.x;
                                p.targetY = t.y;
                                p.isMoving = true;
                            }
                        }

                        /**
                         * Remove a tile from the pool and re-layout remaining tiles.
                         * @param {Tile} tile
                         * @returns {void}
                         */
                        remove(tile) {
                            const idx = this.tiles.indexOf(tile);
                            if (idx >= 0) this.tiles.splice(idx, 1);
                            //renumber remaining
                            for (let i = 0; i < this.tiles.length; i++) {
                                const p = this.tiles[i];
                                p.poolIndex = i;
                                const { x, y } = this.getTarget(i);
                                p.targetX = x;
                                p.targetY = y;
                                p.isMoving = true;
                            }
                        }

                        /**
                         * Find a pooled tile at the given world coordinates (center-based hit test).
                         * @param {number} x
                         * @param {number} y
                         * @returns {Tile|null}
                         */
                        getTileAtPos(x, y) {
                            //tile "radius" (half the side length, very convenient for center coordinates)
                            const rad = this.tileSize / 2;

                            //check tiles in backwards order, because that's front to back
                            for (let i = this.tiles.length - 1; i >= 0; i--) {
                                const {
                                    x: tileX,
                                    y: tileY
                                } = this.getTarget(i);
                                if (
                                    x > tileX - rad && x < tileX + rad &&
                                    y > tileY - rad && y < tileY + rad
                                ) {
                                    return this.tiles[i];
                                }
                            }
                            return null;
                        }

                        /**
                         * Handle pointer input for starting, updating, and ending drags on pooled tiles.
                         * Reads global `mouse` state and updates pool/tiles accordingly.
                         * @returns {void}
                         */
                        handleInput() {
                            const {
                                screenX,
                                screenY,
                                down,
                                wasDown
                            } = mouse;
                            const clickHappened = down && !wasDown;
                            const released = !down && wasDown;

                            if (clickHappened) {
                                const {
                                    x: scaledX,
                                    y: scaledY
                                } = screenToWorld(screenX, screenY);
                                const tile = this.getTileAtPos(scaledX, scaledY);
                                if (tile) {
                                    this.draggedTile = tile;
                                    this.draggedTile.beingDragged = true;
                                    this.draggedTileOriginal = {
                                        x: tile.x,
                                        y: tile.y,
                                        row: tile.row,
                                        col: tile.col
                                    };
                                    this.dragOffsetX = scaledX - tile.x;
                                    this.dragOffsetY = scaledY - tile.y;
                                }
                            } else if (this.draggedTile && down) {
                                const {
                                    x: scaledX,
                                    y: scaledY
                                } = screenToWorld(screenX, screenY);
                                const targetX = scaledX - this.dragOffsetX;
                                const targetY = scaledY - this.dragOffsetY;
                                [this.draggedTile.x, this.draggedTile.y] = [targetX, targetY];

                                const distFromStart = Math.hypot(
                                    this.draggedTile.x - this.draggedTileOriginal.x,
                                    this.draggedTile.y - this.draggedTileOriginal.y
                                );
                                const maxDragDist = this.tileSize * 1.2;
                                const sizeProgress = Math.min(distFromStart / maxDragDist, 1);
                                this.draggedTile.scale = 1 + (sizeProgress * 0.3);

                            } else if (released && this.draggedTile) {
                                let placed = false;

                                //use window.App.rightGrid
                                if (window.App && window.App.rightGrid) {
                                    const placeCell = window.App.rightGrid.getCellAtPos(
                                        this.draggedTile.x, this.draggedTile.y
                                    );
                                    if (placeCell) {
                                        //try to place into the grid
                                        const ok = window.App.rightGrid.placeTile(this.draggedTile, placeCell.col, placeCell.row);
                                        if (ok) {
                                            //remove from pool only when placement succeeded
                                            this.remove(this.draggedTile);
                                            placed = true;
                                            this.draggedTile.beingDragged = false;
                                            this.draggedTile.scale = 1;
                                            this.draggedTile = null;
                                            this.draggedTileOriginal = null;
                                            return;
                                        }
                                        //else tile goes to in pool
                                    }
                                }

                                if (!placed) {
                                    this.invalidDrop = true;
                                    this.invalidDropTile = this.draggedTile;
                                    this.invalidDropTime = 0;
                                    this.invalidDropTile.targetX = this.draggedTileOriginal.x;
                                    this.invalidDropTile.targetY = this.draggedTileOriginal.y;
                                    this.invalidDropTile.isMoving = true;
                                }

                                if (this.draggedTile) this.draggedTile.beingDragged = false;
                                if (this.draggedTile) this.draggedTile.scale = 1;
                                this.draggedTile = null;
                                this.draggedTileOriginal = null;
                            }
                        }

                        /**
                         * Update pool-level timed state (e.g. invalid-drop animations).
                         * @param {number} dt - Delta time in seconds.
                         * @returns {void}
                         */
                        update(dt) {
                            if (this.invalidDrop && this.invalidDropTile) {
                                this.invalidDropTime += dt;
                                const tile = this.invalidDropTile;
                                const dist = Math.hypot(tile.targetX - tile.x, tile.targetY - tile.y);

                                tile.animate(dt);

                                //when tile reaches original position, clear invalid swap
                                if (dist < 2) {
                                    this.invalidDrop = false;
                                    this.invalidDropTile = null;
                                    this.invalidDropTime = 0;
                                }
                            }
                            for (const tile of this.tiles) {
                                if (tile.isMoving) {
                                    tile.animate(dt);
                                }
                            }
                        }
                    }

                    /**
                     * The main tile board class. This is shaped like a rectangle, except
                     * the bottom right is taken out. This stores a 2D array of `Tile` objects,
                     * handles swapping, gravity, match detection, and board updates.
                     */
                    class TileBoard {
                        /**
                         * Create a TileBoard that manages the grid of tiles and game mechanics.
                         * @param {number} [cols1=6]
                         * @param {number} [rows1=12] 
                         * @param {number} [cols2=6]
                         * @param {number} [rows2=6]
                         * @param {number} [boardX=20]
                         * @param {number} [boardY=120]
                         * @param {number} [tileSize=85]
                         */
                        constructor(cols1 = 6, rows1 = 12, cols2 = 6, rows2 = 6, boardX = 20, boardY = 120, tileSize = 85) {
                            this.cols1 = cols1;
                            this.rows1 = rows1;
                            this.cols2 = cols2;
                            this.rows2 = rows2;
                            this.cols = this.cols1 + this.cols2;
                            this.rows = this.rows1;
                            this.boardX = boardX;
                            this.boardY = boardY;
                            this.tileSize = tileSize;
                            this.tiles = Array.from({
                                length: this.rows1
                            }).map(e => []);

                            //tileSize, left = 10, top = 10, parent = null
                            this.pool = new TilePool(this.tileSize, boardX, 12, this, totalBoardWidth);
                            this.selectedTile = null;
                            this.draggedTile = null;
                            this.draggedTileOriginal = null;
                            this.dragOffsetX = 0;
                            this.dragOffsetY = 0;
                            this.scores = 0;
                            this.matchesThisFrame = 0;
                            this.swapInProgress = false;
                            this.invalidSwap = false;
                            this.invalidSwapTile = null;
                            this.invalidSwapTime = 0;
                            this.lastMousePos = {
                                x: 0,
                                y: 0
                            };
                            //{ tile1, tile2 } when user swaps
                            this.pendingUserSwap = null;
                            //store reversing pair
                            this.reversingSwap = null;
                            //set true when reverse animation running
                            this.justReversed = false;

                            this.initBoard();
                        }

                        /**
                         * Initialize or regenerate the board until no initial matches exist
                         * and at least one possible move is present.
                         * @returns {void}
                         */
                        // initBoard() {
                        //     // fill board regenerate entire board until no initial connected matches exist
                        //     this.iterate((row, col) => {
                        //         const colorIndex = Math.floor(Math.random() * tileColors.length);
                        //         const tile = new Tile(col, row, colorIndex);
                        //         tile.updatePosition(this.tileSize, this.boardX, this.boardY);
                        //         this.tiles[row][col] = tile;
                        //         // tag tile with board ref. This allows me to have multiple boards that work together
                        //         tile.board = this;
                        //     });
                        // }
                        initBoard() {
                            if (storedData.tileBoard) {
                                const tbdata = storedData.tileBoard;
                                this.iterate((row, col) => {
                                    const { colorIndex, sides } = tbdata[row][col];
                                    const tile = new Tile(col, row, colorIndex, sides);
                                    tile.updatePosition(this.tileSize, this.boardX, this.boardY);
                                    this.tiles[row][col] = tile;
                                    tile.board = this;
                                });
                            } else {
                                let attempts = 0;
                                do {
                                    this.iterate((row, col) => {
                                        const colorIndex = Math.floor(Math.random() * 3);
                                        const tile = new Tile(col, row, colorIndex);
                                        tile.updatePosition(this.tileSize, this.boardX, this.boardY);
                                        this.tiles[row][col] = tile;
                                        tile.board = this;
                                    });
                                    attempts++;
                                    if (attempts > 200) break;
                                } while (this.findMatches().length > 0 || !this.hasPossibleMove());
                            }
                        }

                        /** Iterates a function through a TileBoard.
                         * 
                         * @param {(r, c) => *} callback
                         * @returns {void}
                         */
                        iterate(callback) {
                            for (let r = 0; r < this.rows; r++) {
                                const cols = r < this.rows2 ? this.cols : this.cols1;
                                for (let c = 0; c < cols; c++) {
                                    callback(r, c);
                                }
                            } 
                        }

                        // initial board will be regenerated if any connected matches are present
                        /**
                         * Check whether a tile placement is valid. Placeholder that currently always returns true.
                         * @param {number} col
                         * @param {number} row
                         * @returns {boolean}
                         */
                        isTileValid(col, row) {
                            return true; // HELP: btw what is this supposed to do, if it checks if in bounds then my function below does just that
                        }

                        /**
                         * Checks if tile row and col is in bounds.
                         * @param {number} row
                         * @param {number} col
                         * @returns {boolean} 
                         */
                        inBounds(row, col) {
                            return (
                                row >= 0 && col >= 0 && (
                                    (row < this.rows2 && col < this.cols) ||
                                    (row < this.rows && col < this.cols1)
                                )
                            );
                        }

                        /**
                         * Return the tile at world coordinates, or null if none.
                         * @param {number} x
                         * @param {number} y
                         * @returns {Tile|null}
                         */
                        getTileAtPos(x, y) {
                            const col = Math.floor((x - this.boardX) / this.tileSize);
                            const row = Math.floor((y - this.boardY) / this.tileSize);

                            if (this.inBounds(row, col)) return this.tiles[row][col];
                            return null;
                        }

                        /**
                         * Handle selection of a tile. If a different tile is already selected,
                         * attempt to swap if adjacent.
                         * @param {Tile} tile
                         * @returns {void}
                         */
                        selectTile(tile) {
                            if (this.swapInProgress) return;

                            if (this.selectedTile === tile) {
                                this.selectedTile = null;
                            } else if (!this.selectedTile) {
                                this.selectedTile = tile;
                            } else {
                                //swap tiles if adjacent
                                if (this.areAdjacent(this.selectedTile, tile)) {
                                    //mark as a user-initiated swap so we can check after animation
                                    this.pendingUserSwap = {
                                        tile1: this.selectedTile,
                                        tile2: tile
                                    };
                                    this.swapTiles(this.selectedTile, tile);
                                }
                                this.selectedTile = tile;
                            }
                        }

                        /**
                         * Test whether two tiles are adjacent on the grid.
                         * @param {Tile} tile1
                         * @param {Tile} tile2
                         * @returns {boolean}
                         */
                        areAdjacent(tile1, tile2) {
                            const colDiff = Math.abs(tile1.col - tile2.col);
                            const rowDiff = Math.abs(tile1.row - tile2.row);
                            return (colDiff === 1 && rowDiff === 0) || (colDiff === 0 && rowDiff === 1);
                        }

                        /**
                         * Swap two tiles in the grid and set them moving toward updated targets.
                         * @param {Tile} tile1
                         * @param {Tile} tile2
                         * @returns {void}
                         */
                        swapTiles(tile1, tile2) {
                            //swap positions in grid
                            [this.tiles[tile1.row][tile1.col], this.tiles[tile2.row][tile2.col]] = [this.tiles[tile2.row][tile2.col], this.tiles[tile1.row][tile1.col]];

                            //store original data before swapping properties
                            const originalRow1 = tile1.row;
                            const originalCol1 = tile1.col;

                            //swap row/col properties
                            tile1.row = tile2.row;
                            tile1.col = tile2.col;
                            tile2.row = originalRow1;
                            tile2.col = originalCol1;

                            //ensure tiles animate towards their targets
                            tile1.isMoving = true;
                            tile2.isMoving = true;

                            //update target positions (animation will move from current x/y)
                            tile1.updatePosition(this.tileSize, this.boardX, this.boardY);
                            tile2.updatePosition(this.tileSize, this.boardX, this.boardY);

                            this.swapInProgress = true;
                        }

                        /**
                         * Reverse a previously performed swap (animation-aware).
                         * @param {Tile} tile1
                         * @param {Tile} tile2
                         * @returns {void}
                         */
                        reverseSwap(tile1, tile2) {
                            //reverse a swap with animation
                            [this.tiles[tile1.row][tile1.col], this.tiles[tile2.row][tile2.col]] = [this.tiles[tile2.row][tile2.col], this.tiles[tile1.row][tile1.col]];

                            const originalRow1 = tile1.row;
                            const originalCol1 = tile1.col;

                            tile1.row = tile2.row;
                            tile1.col = tile2.col;
                            tile2.row = originalRow1;
                            tile2.col = originalCol1;

                            //ensure reverse animates
                            tile1.isMoving = true;
                            tile2.isMoving = true;

                            tile1.updatePosition(this.tileSize, this.boardX, this.boardY);
                            tile2.updatePosition(this.tileSize, this.boardX, this.boardY);

                            //mark that we've initiated a reverse so update() can handle end-of-animation cleanup
                            this.justReversed = true;
                            this.swapInProgress = true;
                        }

                        /**
                         * Find connected components of tiles that satisfy matching rules.
                         * Returns an array of matched tiles.
                         * @returns {Tile[]}
                         */
                        findMatches() {
                            // find connected components where tiles have same color and both have indicators on the touching side
                            const matchedComponents = [];
                            const visited = Array.from({
                                length: this.rows2
                            }, () => Array(this.cols).fill(false)).concat(
                                Array.from({
                                    length: this.rows
                                }, () => Array(this.cols1).fill(false))
                            );

                            this.iterate((r, c) => {
                                const start = this.tiles[r][c];
                                //if (!start || visited[r][c]) return;
                                if (!start || visited[r][c] || start.immune) return;

                                const color = start.colorIndex;
                                const stack = [start];
                                const component = [];

                                while (stack.length) {
                                    const t = stack.pop();
                                    const tr = t.row;
                                    const tc = t.col;
                                    if (visited[tr][tc]) continue;
                                    visited[tr][tc] = true;
                                    component.push(t);

                                    //check four neighbors for bidirectional (fun word lol) indicator connection
                                    const neighbors = [
                                        {
                                            rr: tr - 1,
                                            cc: tc,
                                            side: 'up',
                                            opp: 'down'
                                        },
                                        {
                                            rr: tr + 1,
                                            cc: tc,
                                            side: 'down',
                                            opp: 'up'
                                        },
                                        {
                                            rr: tr,
                                            cc: tc - 1,
                                            side: 'left',
                                            opp: 'right'
                                        },
                                        {
                                            rr: tr,
                                            cc: tc + 1,
                                            side: 'right',
                                            opp: 'left'
                                        }
                                    ];

                                    for (const n of neighbors) {
                                        if (!this.inBounds(n.rr, n.cc)) continue;
                                        // const nb = this.tiles[n.rr][n.cc];
                                        // if (!nb) continue;
                                        // if (visited[n.rr][n.cc]) continue;
                                        const nb = this.tiles[n.rr][n.cc];
                                        if (!nb || nb.immune) continue;
                                        if (visited[n.rr][n.cc]) continue;
                                        
                                        //if (nb.colorIndex !== color && nb.colorIndex !== 3) continue; // bomb tiles are
                                        if (color !== 3 && nb.colorIndex !== color && nb.colorIndex !== 3) continue;
                                        //both tiles must have indicators on the contacting sides
                                        if (t.sides[n.side] && nb.sides[n.opp]) {
                                            stack.push(nb);
                                        }
                                    }
                                }

                                if (component.length >= 3) {
                                    //limit match removal to a maximum of 3 tiles per connected component
                                    //const toAdd = component.slice(0, 3);
                                    //for (const tile of component) matched.push(tile);
                                    matchedComponents.push(component);
                                }
                            });

                            return matchedComponents;
                        }

                        /**
                         * Mark matched tiles for pooling and initiate their movement into the pool.
                         * @returns {void}
                         */
                        handleMatches(matchedComponents) {
                            if (!matchedComponents) matchedComponents = this.findMatches();
                            if (matchedComponents.length === 0) { this.swapInProgress = false; return; }

                            matchedComponents.forEach(component => component.forEach(tile => {
                                tile.matched = true;
                                if (tile.colorIndex == 3) tile.toBeDeleted = true; else tile.toBePooled = true;
                                tile.inPool = false;
                                tile.isMoving = false;
                            }));

                            if (window.App) window.App.addShake(matchedComponents.length * 2.4);

                            const intoPool = new Set(matchedComponents.flat());

                            // Bombs
                            let bombsInMatch = [...intoPool].filter(tile => tile.colorIndex === 3);
                            bombsInMatch.forEach(bomb => {
                                // pixel-art explosion effect
                                PixelArtExploder.explode(bomb, this.tileSize, window.App.matchBurst, 3);
                                //burst from bomb edges
                                const color = pixelArtColors[3];
                                const origins = [
                                    [bomb.x, bomb.y - this.tileSize / 2],
                                    [bomb.x, bomb.y + this.tileSize / 2],
                                    [bomb.x - this.tileSize / 2, bomb.y],
                                    [bomb.x + this.tileSize / 2, bomb.y],
                                ];
                                for (const [ox, oy] of origins) window.App.placeBurst.add(ox, oy, color);
                                // radius clear
                                for (let r = bomb.row - 2; r <= bomb.row + 2; r++) {
                                    for (let c = bomb.col - 2; c <= bomb.col + 2; c++) {
                                        if (this.inBounds(r, c) && this.tiles[r][c]) {
                                            intoPool.add(this.tiles[r][c]);
                                        }
                                    }
                                }
                                intoPool.delete(bomb);
                            });

                            const total = this.pool.tiles.length + intoPool.size;
                            let slot = this.pool.tiles.length;
                            intoPool.forEach(tile => {
                                //final total current pool size and all tiles heading here
                                const t = this.pool.getTarget(slot, total);
                                slot ++;

                                tile.targetX = t.x;
                                tile.targetY = t.y;
                                tile.isMoving = true;
                                tile.rotation = 0;
                                tile.toBePooled = true;
                                this.swapInProgress = true;
                            });

                            // If the matched components have 4 or more tiles in them, create a bomb tile
                            matchedComponents.forEach(component => {
                                if (component.length >= 4) {
                                    const rand = component[Math.floor(Math.random() * component.length)];
                                    this.tiles[rand.row][rand.col] = new Tile(rand.col, rand.row, 3);
                                    this.tiles[rand.row][rand.col].updatePosition(this.tileSize, this.boardX, this.boardY);
                                }
                            });

                            this.swapInProgress = true;
                        }


                        /**
                         * Apply gravity to the board so tiles fall down into empty spaces.
                         * @returns {void}
                         */
                        applyGravity() {
                            for (let col = 0; col < this.cols; col++) {
                                //for the narrow part of the L-shape, only rows2 rows are valid
                                const maxRow = col < this.cols1 ? this.rows - 1 : this.rows2 - 1;
                                let writePos = maxRow;
                                for (let row = maxRow; row >= 0; row--) {
                                    if (this.tiles[row][col] != null) {
                                        if (row !== writePos) {
                                            this.tiles[writePos][col] = this.tiles[row][col];
                                            this.tiles[writePos][col].row = writePos;
                                            this.tiles[writePos][col].isMoving = true;
                                            this.tiles[row][col] = null;
                                        }
                                        writePos--;
                                    }
                                }
                            }

                            //update positions but never touch tiles that are already flying to the pool
                            for (let row = 0; row < this.rows; row++) {
                                for (let col = 0; col < this.cols; col++) {
                                    const t = this.tiles[row][col];
                                    if (t && !t.toBePooled) {
                                        t.updatePosition(this.tileSize, this.boardX, this.boardY);
                                    }
                                }
                            }
                        }

                        /**
                         * Fill empty slots on the board by creating new tiles and then check for cascades.
                         * @returns {void}
                         */
                        fillGaps() {
                            for (let col = 0; col < this.cols; col++) {
                                for (let row = 0; row < this.rows; row++) {
                                    if (this.tiles[row][col] === null) {
                                        const colorIndex = Math.floor(Math.random() * 3);
                                        const tile = new Tile(col, row, colorIndex);
                                        tile.y = this.boardY - this.tileSize;
                                        tile.targetY = this.boardY + row * this.tileSize + this.tileSize / 2;
                                        tile.targetX = this.boardX + col * this.tileSize + this.tileSize / 2;
                                        tile.x = tile.targetX;
                                        this.tiles[row][col] = tile;
                                        //same as initBoard:
                                        tile.board = this;
                                    }
                                }
                            }

                        }

                        /**
                         * Determine whether there exists at least one legal adjacent swap that would create a match.
                         * @returns {boolean}
                         */
                        hasPossibleMove() {
                            //returns true if there exists at least one adjacent swap that would create a match
                            const inBounds = (r, c) => r >= 0 && r < this.rows && c >= 0 && c < this.cols;

                            for (let r = 0; r < this.rows; r++) {
                                for (let c = 0; c < this.cols; c++) {
                                    const t = this.tiles[r][c];
                                    if (!t) continue;

                                    //check right neighbor
                                    const rc = c + 1;
                                    if (rc < this.cols) {
                                        const t2 = this.tiles[r][rc];
                                        if (t2) {
                                            //swap inplace
                                            this.tiles[r][c] = t2;
                                            this.tiles[r][rc] = t;
                                            const origR1 = t.row,
                                                origC1 = t.col,
                                                origR2 = t2.row,
                                                origC2 = t2.col;
                                            t.row = r;
                                            t.col = rc;
                                            t2.row = r;
                                            t2.col = c;

                                            const matches = this.findMatches();

                                            //swap back
                                            this.tiles[r][c] = t;
                                            this.tiles[r][rc] = t2;
                                            t.row = origR1;
                                            t.col = origC1;
                                            t2.row = origR2;
                                            t2.col = origC2;

                                            if (matches.length > 0) return true;
                                        }
                                    }

                                    //check down neighbor
                                    const rr = r + 1;
                                    if (rr < this.rows) {
                                        const t2 = this.tiles[rr][c];
                                        if (t2) {
                                            this.tiles[r][c] = t2;
                                            this.tiles[rr][c] = t;
                                            const origR1 = t.row,
                                                origC1 = t.col,
                                                origR2 = t2.row,
                                                origC2 = t2.col;
                                            t.row = rr;
                                            t.col = c;
                                            t2.row = r;
                                            t2.col = c;

                                            const matches = this.findMatches();

                                            this.tiles[r][c] = t;
                                            this.tiles[rr][c] = t2;
                                            t.row = origR1;
                                            t.col = origC1;
                                            t2.row = origR2;
                                            t2.col = origC2;

                                            if (matches.length > 0) return true;
                                        }
                                    }
                                }
                            }

                            return false;
                        }

                        /**
                         * Randomly shuffle tiles until a solvable board (no immediate matches and at least one possible move) is produced.
                         * @returns {void}
                         */
                        reshuffleBoard() {
                            //flatten tiles
                            const list = [];
                            for (let r = 0; r < this.rows; r++) {
                                for (let c = 0; c < this.cols; c++) {
                                    if (this.tiles[r][c]) list.push(this.tiles[r][c]);
                                }
                            }

                            //try shuffling until a solvable board (no immediate matches and hasPossibleMove)
                            const shuffleArray = (a) => {
                                for (let i = a.length - 1; i > 0; i--) {
                                    const j = Math.floor(Math.random() * (i + 1));
                                    [a[i], a[j]] = [a[j], a[i]];
                                }
                            };

                            let attempts = 0;
                            do {
                                shuffleArray(list);
                                //reassign
                                let idx = 0;
                                for (let r = 0; r < this.rows; r++) {
                                    for (let c = 0; c < this.cols; c++) {
                                        const t = list[idx++];
                                        this.tiles[r][c] = t || null;
                                        if (t) {
                                            t.row = r;
                                            t.col = c;
                                            t.updatePosition(this.tileSize, this.boardX, this.boardY);
                                            t.x = t.targetX;
                                            t.y = t.targetY;
                                            t.isMoving = false;
                                        }
                                    }
                                }
                                attempts++;
                                if (attempts > 200) break;
                            } while (this.findMatches().length > 0 || !this.hasPossibleMove());
                        }

                        /**
                         * Update board state: animate tiles, detect pooling completions, handle swaps and matches.
                         * @param {number} dt - Delta time in seconds.
                         * @returns {void}
                         */
                        update(dt) {
                            // update all tiles
                            //this.iterate((row, col) => this.tiles[row][col].animate(dt));
                            this.iterate((row, col) => { if (this.tiles[row][col]) this.tiles[row][col].animate(dt); });

                            // check for tiles that finished animating into the pool and move them from grid to pool
                            let removedThisFrame = [];
                            this.iterate((row, col) => {
                                const t = this.tiles[row][col];
                                if (t && t.toBePooled && !t.isMoving && !t.inPool) {
                                    // remove from grid and add to pool
                                    this.tiles[row][col] = null;
                                    t.inPool = true;
                                    t.toBePooled = false;
                                    //ensure position remains at pool target
                                    t.x = t.targetX;
                                    t.y = t.targetY;
                                    this.pool.add(t);
                                    removedThisFrame.push(t);
                                } else if (t && t.toBeDeleted) {
                                    // remove from grid and add to pool
                                    this.tiles[row][col] = null;
                                    removedThisFrame.push(t);
                                }
                            });

                            if (removedThisFrame.length > 0) {
                                this.applyGravity();
                                this.fillGaps();
                                // don't interupt 
                                this.swapInProgress = true;
                            }

                            // handle invalid swap completion
                            if (this.invalidSwap && this.invalidSwapTile) {
                                this.invalidSwapTime += dt;
                                const tile = this.invalidSwapTile;
                                const dist = Math.hypot(tile.targetX - tile.x, tile.targetY - tile.y);

                                //when tile reaches original position, clear invalid swap
                                if (dist < 2) {
                                    this.invalidSwap = false;
                                    this.invalidSwapTile = null;
                                    this.invalidSwapTime = 0;
                                }
                            }

                            //only check for matches after all tiles have finished falling
                            let anyMoving = false;
                            this.iterate((row, col) => {
                                if (this.tiles[row][col] && this.tiles[row][col].isMoving) {
                                    anyMoving = true;
                                }
                            });

                            if (!anyMoving && this.swapInProgress) {
                                //if this was a user-initiated swap, check its result after the visual swap and grav settles
                                if (this.pendingUserSwap) {
                                    const matches = this.findMatches();
                                    if (matches.length > 0) {
                                        //valid swap so clear pending and handle matches normally
                                        this.pendingUserSwap = null;
                                        //pass in
                                        this.handleMatches(matches);
                                    } else {
                                        //invalid swap so reverse with animation and show invalid overlay
                                        const t1 = this.pendingUserSwap.tile1;
                                        const t2 = this.pendingUserSwap.tile2;
                                        this.pendingUserSwap = null;
                                        this.invalidSwap = true;
                                        this.invalidSwapTile = t1;
                                        this.invalidSwapTime = 0;
                                        this.reversingSwap = {
                                            tile1: t1,
                                            tile2: t2
                                        };
                                        this.reverseSwap(t1, t2);
                                        if (window.App) window.App.addShake(2.5);
                                    }
                                } else if (this.justReversed) {
                                    //finished reversing an invalid swap clear flags
                                    this.swapInProgress = false;
                                    this.justReversed = false;
                                    this.invalidSwap = false;
                                    this.invalidSwapTile = null;
                                    this.invalidSwapTime = 0;
                                    this.reversingSwap = null;
                                } else {
                                    //check for cascade matches after gravity settles
                                    const matches = this.findMatches();
                                    if (matches.length > 0) {
                                        //pass in baby
                                        this.handleMatches(matches);
                                    } else {
                                        if (!this.hasPossibleMove()) this.reshuffleBoard();
                                        this.swapInProgress = false;
                                    }
                                }
                            }
                        }

                        /**
                         * Render the board, grid, pooled tiles, and visual feedback to the global `ctx`.
                         * @returns {void}
                         */
                        draw() {
                            //draw board background
                            ctx.fillStyle = "rgba(224, 221,211,255)";
                            ctx.fillRect(
                                this.boardX - 5,
                                this.boardY - 5,
                                this.cols1 * this.tileSize + 10,
                                this.rows1 * this.tileSize + 10
                            );
                            ctx.fillRect(
                                this.boardX + this.cols1 * this.tileSize + 5,
                                this.boardY - 5,
                                this.cols2 * this.tileSize,
                                this.rows2 * this.tileSize + 10
                            );

                            //draw tiles
                            this.iterate((row, col) => {
                                const tile = this.tiles[row][col];
                                if (tile && tile != this.draggedTile && !tile.toBePooled) {
                                    tile.draw(this.tileSize, false, window.App.matchedYet);
                                }
                            });

                            // draw dragged tile   
                            if (this.draggedTile) this.draggedTile.draw(this.tileSize, true);

                            //draw pool area
                            const poolTop = 6;
                            const poolHeight = this.tileSize + 8;
                            ctx.save();
                            ctx.fillStyle = "rgba(224, 221, 211, 255)";
                            const red = window.App?.turnTimer?.timeLeft <= 5;
                            ctx.strokeStyle = red ? "rgba(255, 25, 25)" : "rgba(25, 25, 25)"; 
                            ctx.lineWidth = 4;
                            ctx.fillRect(this.boardX - 5, poolTop, totalBoardWidth + 10, poolHeight + 5);
                            ctx.strokeRect(this.boardX - 5, poolTop, totalBoardWidth + 10, poolHeight + 5);
                            ctx.stroke(); 
                            ctx.globalAlpha = 1; 
                            ctx.restore();

                            //draw invalid swap feedback
                            if (this.invalidSwap && this.invalidSwapTile) {
                                const flashIntensity = Math.max(0, 1 - (this.invalidSwapTime / 0.3));
                                const alphaFlash = flashIntensity * 0.4;

                                ctx.fillStyle = `rgba(255, 80, 80, ${alphaFlash})`;
                                ctx.fillRect(
                                    this.boardX - 5,
                                    this.boardY - 5,
                                    this.cols * this.tileSize + 10,
                                    this.rows * this.tileSize + 10
                                );
                            }
                        }

                        /**
                         * Handle mouse/touch input for selecting, dragging and dropping tiles on the board.
                         * Reads global `mouse` state.
                         * @returns {void}
                         */
                        handleInput() {
                            const {
                                screenX,
                                screenY,
                                down,
                                wasDown
                            } = mouse;
                            //detect drag 
                            const clickHappened = down && !wasDown;
                            const released = !down && wasDown;
                            if (clickHappened) {
                                //start dragging a tile use global screenToWorld function
                                const worldPos = screenToWorld(screenX, screenY);
                                const scaledX = worldPos.x;
                                const scaledY = worldPos.y;

                                const tile = this.getTileAtPos(scaledX, scaledY);
                                if (tile && !this.swapInProgress && !this.invalidSwap) {
                                    this.draggedTile = tile;
                                    this.draggedTile.beingDragged = true;
                                    this.draggedTileOriginal = {
                                        x: tile.x,
                                        y: tile.y,
                                        row: tile.row,
                                        col: tile.col
                                    };
                                    this.dragOffsetX = scaledX - tile.x;
                                    this.dragOffsetY = scaledY - tile.y;
                                }
                            } else if (this.draggedTile && down) {
                                //update drag position
                                const worldPos = screenToWorld(screenX, screenY);
                                const scaledX = worldPos.x;
                                const scaledY = worldPos.y;

                                const targetX = scaledX - this.dragOffsetX;
                                const targetY = scaledY - this.dragOffsetY;

                                //directly set position
                                this.draggedTile.x = targetX;
                                this.draggedTile.y = targetY;

                                //calc distance from original and apply size curve
                                const distFromStart = Math.hypot(
                                    this.draggedTile.x - this.draggedTileOriginal.x,
                                    this.draggedTile.y - this.draggedTileOriginal.y
                                );

                                //size grows as drag distance increases (easing function)
                                const maxDragDist = this.tileSize * 1.2;
                                const sizeProgress = Math.min(distFromStart / maxDragDist, 1);
                                this.draggedTile.scale = 1 + (sizeProgress * 0.3);
                            } else if (released && this.draggedTile) {
                                const tile = this.draggedTile;
                                const originalTile = this.draggedTileOriginal;
                                let swapped = false;

                                //try board-to-board swap with nearest adjacent tile
                                const directions = [{
                                        dc: -1,
                                        dr: 0
                                    },
                                    {
                                        dc: 1,
                                        dr: 0
                                    },
                                    {
                                        dc: 0,
                                        dr: -1
                                    },
                                    {
                                        dc: 0,
                                        dr: 1
                                    }
                                ];

                                for (const dir of directions) {
                                    const targetCol = tile.col + dir.dc;
                                    const targetRow = tile.row + dir.dr;

                                    if (targetCol >= 0 && targetCol < this.cols &&
                                        targetRow >= 0 && targetRow < this.rows) {
                                        const targetTile = this.tiles[targetRow][targetCol];
                                        if (targetTile) {
                                            const dist = Math.hypot(
                                                tile.x - targetTile.x,
                                                tile.y - targetTile.y
                                            );
                                            if (dist < this.tileSize * 0.6) {
                                                this.swapTiles(tile, targetTile);
                                                this.pendingUserSwap = {
                                                    tile1: tile,
                                                    tile2: targetTile
                                                };
                                                swapped = true;
                                                break;
                                            }
                                        }
                                    }
                                }

                                //if no swap, animate back to original board position
                                if (!swapped) {
                                    tile.targetX = originalTile.x;
                                    tile.targetY = originalTile.y;
                                    tile.isMoving = true;
                                } else {
                                    // otherwise prevent future matched in the same turn
                                    window.App.matchedYet = true;
                                }

                                if (this.draggedTile) this.draggedTile.beingDragged = false;
                                if (this.draggedTile) this.draggedTile.scale = 1;
                                this.draggedTile = null;
                                this.draggedTileOriginal = null;
                            }
                        }

                        drawPool() {
                            //draw matched tiles still flying toward the pool (above pool background)
                            this.iterate((row, col) => {
                                const t = this.tiles[row][col];
                                if (t && t.toBePooled) t.draw(this.tileSize, false);
                            });
                            //draw settled pool tiles
                            for (let i = 0; i < this.pool.tiles.length; i++) {
                                const tile = this.pool.tiles[i];
                                if (tile !== this.pool.draggedTile) {
                                    tile.draw(this.tileSize, false);
                                }
                            }
                            //dragged pool tile always on top
                            if (this.pool.draggedTile) {
                                this.pool.draggedTile.draw(this.tileSize, true);
                            }
                        }
                    }

                    /**
                     * GridController: right-side placement grid that accepts tiles from the pool
                     * but enforces placement rules (starting tile, side-indicator alignment).
                     */
                    class GridController {
                        /**
                         * Create a GridController.
                         * @param {number} x - Left edge of the grid in canvas/world coordinates.
                         * @param {number} y - Top edge of the grid in canvas/world coordinates.
                         * @param {number} displayW - Total pixel width of the grid display area.
                         * @param {number} displayH - Total pixel height of the grid display area.
                         * @param {number} cellSize - Width and height of each individual cell in pixels.
                         */
                        constructor(x, y, displayW, displayH, cellSize) {
                            this.x = x;
                            this.y = y;
                            this.dw = displayW;
                            this.dh = displayH;
                            this.panX = -this.dw / 2 + cellSize / 2;
                            this.panY = -this.dh / 2 + cellSize / 2;
                            this.cellSize = cellSize;
                            this.tiles = [];
                            /*
                            //tile dragging in grid 
                            this.draggedTile = null;
                            this.draggedOrigCol = null;
                            this.draggedOrigRow = null;
                            this.dragOffsetX = 0;
                            this.dragOffsetY = 0;

                            //alogirthm check for swapping
                            this.invalidSwap = false;
                            this.invalidSwapTimer = 0;*/

                            const startCol = 0;
                            const startRow = 0;

                            const startTile = new Tile(startCol, startRow, 0);

                            //got to make sure start tile is compatible lol
                            startTile.sides = {
                                left: true,
                                right: true,
                                up: true,
                                down: true
                            };

                            this.panning = false;

                            // offscreen canvas
                            this.offCanvas = document.createElement("canvas");
                            this.offCanvas.width = this.dw;
                            this.offCanvas.height = this.dh;
                            this.offCtx = this.offCanvas.getContext("2d");

                            //place it without checks
                            this._placeInternal(startTile, startCol, startRow);

                            if (storedData.rightGrid) {
                                for (const tileData of storedData.rightGrid) {
                                    const { col, row, tile: { colorIndex, sides} } = tileData;
                                    const tile = new Tile(col, row, colorIndex, sides);
                                    this.tiles.push({ col, row, tile });
                                }
                            }
                        }

                        /**
                         * Convert world/canvas coordinates to a grid cell address.
                         * Returns null if the point falls outside the grid's positive cell space.
                         * @param {number} wx - World X coordinate.
                         * @param {number} wy - World Y coordinate.
                         * @returns {{col: number, row: number}|null} The cell under the point, or null.
                         */
                        getCellAtPos(wx, wy) {
                            const col = Math.floor((wx - this.x + this.panX) / this.cellSize);
                            const row = Math.floor((wy - this.y + this.panY) / this.cellSize);
                            return {
                                col,
                                row
                            };
                            return null;
                        }

                        /**
                         * Unconditionally register a tile at the given cell and snap its visual
                         * position to the cell center. Does not validate placement rules.
                         * Use `placeTile` for rule-checked placement from the pool.
                         * @param {Tile} tile - The tile to place.
                         * @param {number} col - Destination column index.
                         * @param {number} row - Destination row index.
                         * @returns {void}
                         */
                        _placeInternal(tile, col, row) {
                            this.tiles.push({
                                tile,
                                col,
                                row,
                                turn: (window.App?.turn ?? 0)
                            });
                            tile.inPool = false;
                            tile.inGrid = true;
                            tile.matched = false;
                            tile.opacity = 1;
                            tile.row = row;
                            tile.col = col;

                            tile.placedOnTurn = window.App ? window.App.turn : 0;

                            const cx = this.x + col * this.cellSize + this.cellSize / 2;
                            const cy = this.y + row * this.cellSize + this.cellSize / 2;
                            tile.targetX = cx;
                            tile.targetY = cy;
                            tile.x = cx;
                            tile.y = cy;
                            tile.isMoving = false;
                            tile.beingDragged = false; 
                            tile.scale = 1;

                            //pop particles when a tile lands in the placement grid
                            if (window.App && window.App.placeBurst && tile.inGrid) {
                                const color = pixelArtColors[tile.colorIndex];
                                const cs = this.cellSize;
                                const bx = this.x - this.panX + col * cs;
                                const by = this.y - this.panY + row * cs;

                                //from edges
                                const origins = [
                                    [bx + cs / 2, by],
                                    [bx + cs / 2, by + cs],
                                    [bx, by + cs / 2],
                                    [bx + cs, by + cs / 2],
                                ];
                                for (const [ox, oy] of origins) {
                                    window.App.placeBurst.add(ox, oy, color);
                                }
                                window.App.addShake(10);
                            } 
                            
                        }

                        /**
                         * Attempt to place a tile from the pool into the grid at the given cell,
                         * running side-indicator validation first via `canPlace`.
                         * @param {Tile} tile - The tile to place.
                         * @param {number} col - Target column index.
                         * @param {number} row - Target row index.
                         * @returns {boolean} True if the tile was successfully placed, false if validation failed.
                         */
                        placeTile(tile, col, row) {
                            if (!this.canPlace(tile, col, row)) return false;
                            this._placeInternal(tile, col, row);
                            if (tile.colorIndex === 3) {
                                // super rare bomb tile, obtained by blowing up a bomb tile in
                                // matching area w/ another bomb tile
                                // reward lol
                                window.App.score += 20;
                            } else {
                                // my brain is too dead rn to use the canPlace stuff for this so...
                                const neighbors = [
                                    {
                                        dc: -1,
                                        dr: 0,
                                        mySide: 'left',
                                        theirSide: 'right'
                                    },
                                    {
                                        dc: 1,
                                        dr: 0,
                                        mySide: 'right',
                                        theirSide: 'left'
                                    },
                                    {
                                        dc: 0,
                                        dr: -1,
                                        mySide: 'up',
                                        theirSide: 'down'
                                    },
                                    {
                                        dc: 0,
                                        dr: 1,
                                        mySide: 'down',
                                        theirSide: 'up'
                                    }
                                ];

                                let numNeighborsSameColor = 0;
                                for (const n of neighbors) {
                                    const nc = col + n.dc;
                                    const nr = row + n.dr;
                                    const neighbor = this.getTile(nc, nr);
                                    if (!neighbor) continue;
                                    if (neighbor.tile.colorIndex === tile.colorIndex) {
                                        numNeighborsSameColor ++;
                                    }
                                }
                                window.App.score += 5 + numNeighborsSameColor;
                            }
                            return true;
                        }

                        /**
                         * Return the tile occupying the given cell, or undefined if the cell is empty.
                         * @param {number} col - Column index to look up.
                         * @param {number} row - Row index to look up.
                         * @returns {Tile|undefined}
                         */
                        getTile(col, row) {
                            return this.tiles.find(e => e.col == col && e.row == row);
                        }

                        /**
                         * Validate whether a tile may be placed at the given cell.
                         * Rules enforced:
                         *  - Cell must be within grid bounds.
                         *  - Cell must currently be empty.
                         *  - The tile must have at least one existing neighbor.
                         *  - For every neighbor, the touching sides must either both have indicators or both lack them.
                         * @param {Tile} tile - The tile being considered for placement.
                         * @param {number} col - Target column index.
                         * @param {number} row - Target row index.
                         * @returns {boolean} True if placement is legal, false otherwise.
                         */
                        canPlace(tile, col, row) {
                            if (this.getTile(col, row)) return false;

                            const currentTurn = window.App ? window.App.turn : 0;

                            const neighbors = [
                                {
                                    dc: -1,
                                    dr: 0,
                                    mySide: 'left',
                                    theirSide: 'right'
                                },
                                {
                                    dc: 1,
                                    dr: 0,
                                    mySide: 'right',
                                    theirSide: 'left'
                                },
                                {
                                    dc: 0,
                                    dr: -1,
                                    mySide: 'up',
                                    theirSide: 'down'
                                },
                                {
                                    dc: 0,
                                    dr: 1,
                                    mySide: 'down',
                                    theirSide: 'up'
                                }
                            ];

                            let numNeighbors = 0;
                            for (const n of neighbors) {
                                const nc = col + n.dc;
                                const nr = row + n.dr;
                                const neighbor = this.getTile(nc, nr);
                                if (!neighbor) continue;
                                // if tile is placed less than 2 turns ago
                                if ((window.App?.turn ?? 0) - neighbor.turn <= 2) {
                                    numNeighbors++;
                                }
                                if (
                                    (tile.sides?.[n.mySide] && neighbor.tile.sides?.[n.theirSide]) ||
                                    (!tile.sides?.[n.mySide] && !neighbor.tile.sides?.[n.theirSide])
                                ) {
                                    continue;
                                }
                                return false;
                            }

                            return numNeighbors > 0;
                        }

                        /**
                         * Advance grid animations and decay timed state.
                         * @param {number} dt - Delta time in seconds since the last frame.
                         * @returns {void}
                         */
                        update(dt) {
                            const currentTurn = window.App ? window.App.turn : 0;
                            for (const entry of this.tiles) {
                                if (!entry.tile) continue;
                                entry.tile.animate(dt);
                            }
                        }

                        /**
                         * Pan the grid to the last placed tile.
                         * @returns {void}
                         */
                        panToLastPlaced() {
                            const { row, col } = this.tiles[this.tiles.length - 1];
                            this.panX = -this.dw / 2 + this.cellSize * (col + 0.5);
                            this.panY = -this.dh / 2 + this.cellSize * (row + 0.5);
                        }

                        /**
                         * Pan the grid, based on keys.
                         * @returns {void}
                         */
                        pan() {
                            const { down, screenX, screenY } = mouse;
                            const { x, y } = screenToWorld(screenX, screenY);
                            if (!this.panning && mouse.down && !mouse.wasDown &&
                                x >= this.x && x <= this.x + this.dw &&
                                y >= this.y && y <= this.y + this.dh
                            ) {
                                this.panning = true;
                                this.panStartX = this.panX + x;
                                this.panStartY = this.panY + y;
                            }
                            if (this.panning && mouse.down) {
                                this.panX = this.panStartX - x;
                                this.panY = this.panStartY - y;
                            }
                            if (this.panning && !mouse.down) {
                                this.panning = false;
                            }
                        }

                        /**
                         * Render the grid background, cell lines, all placed tiles, the in-flight
                         * dragged tile (drawn last so it appears on top), and the invalid-swap
                         * flash overlay if active.
                         * @returns {void}
                         */
                        draw() {
                            // offscreen canvas
                            const octx = this.offCtx;
                            octx.clearRect(0, 0, this.dw, this.dh);
                            octx.fillStyle = "rgba(224, 221,211,255)";
                            octx.fillRect(0, 0, this.dw, this.dh);
                            
                            ctx.save();
                            
                            ctx.save();
                            ctx.setLineDash([]);
                            const red = window.App?.turnTimer?.timeLeft <= 5;
                            ctx.strokeStyle = red ? "rgba(255, 25, 25)" : "rgba(25, 25, 25)"; 
                            ctx.lineWidth = 8;

                            ctx.beginPath(); 
                            ctx.moveTo(this.x - 4, this.y); 
                            ctx.lineTo(this.x + this.dw + 4, this.y);
                            ctx.stroke();

                            ctx.beginPath();
                            ctx.moveTo(this.x, this.y); 
                            ctx.lineTo(this.x, this.y + this.dh + 4);
                            ctx.stroke();
                            ctx.setLineDash([]);

                            ctx.restore();

                            octx.setLineDash([5, 5]);
                            octx.strokeStyle = 'rgba(18, 18, 18, 0.6)';
                            // a little bit of math to find where to put the first line
                            const startingX = -this.panX + Math.ceil(this.panX / this.cellSize) * this.cellSize;
                            const dashX = -this.panY + Math.ceil(this.panY / 10) * 10;
                            for (let x = startingX; x <= this.dw; x += this.cellSize) {
                                octx.beginPath();
                                octx.moveTo(x, -5 + dashX);
                                octx.lineTo(x, this.dh + dashX);
                                octx.stroke();
                            }
                            const startingY = -this.panY + Math.ceil(this.panY / this.cellSize) * this.cellSize;
                            const dashY = -this.panX + Math.ceil(this.panX / 10) * 10;
                            for (let y = startingY; y <= this.dh; y += this.cellSize) {
                                octx.beginPath();
                                octx.moveTo(-5 + dashY, y);
                                octx.lineTo(this.dw + dashY, y);
                                octx.stroke();
                            }

                            if (window.App && window.App.placeBurst) {
                                for (const p of window.App.placeBurst.particles) {
                                    const px = p.position.x - this.x;
                                    const py = p.position.y - this.y;
                                    octx.save();
                                    octx.translate(px + p.size / 2, py + p.size / 2);
                                    octx.rotate(p.angle / 180 * Math.PI);
                                    octx.fillStyle = p.color;
                                    octx.globalAlpha = p.opacity;
                                    octx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
                                    octx.restore();
                                }
                            }

                            for (const entry of this.tiles) {
                                if (entry && entry.tile) {
                                    const et = entry.tile;
                                    // The .5 is necessary because the draw call draws it relative to center
                                    PixelArt.draw(
                                        octx,
                                        et.colorIndex,
                                        et.sides,
                                        (entry.col + 0.5) * this.cellSize - this.panX,
                                        (entry.row + 0.5) * this.cellSize - this.panY,
                                        this.cellSize,
                                        et.opacity,
                                        et.scale,
                                        false,
                                        (window.App?.turn ?? 0) - entry.turn >= 2 // gray the tile if placed more than 2 turns ago
                                    );
                                }
                            }
                            octx.setLineDash([]);
                            /*
                            //draw the tile being dragged above everything else
                            if (this.draggedTile) {
                                const drt = this.draggedTile;
                                PixelArt.draw(
                                    ctx,
                                    drt.colorIndex,
                                    drt.sides,
                                    drt.x * this.cellSize, drt.y * this.cellSize,
                                    this.cellSize,
                                    drt.opacity,
                                    drt.scale,
                                    true
                                );
                            }*/

                            ctx.drawImage(this.offCanvas, this.x, this.y);
                            ctx.restore();
                        }
                    }

                    /**
                     * TurnTimer: basically a timer that tells you how much time left you have in
                     * a turn, among a few other cool things
                     */
                    class TurnTimer {
                        /** Constructs an instance of TurnTimer.
                         * 
                         * @constructor
                         * @param {number} duration - Duration in seconds
                         */
                        constructor(duration) {
                            this.lastReset = (Date.now() - (storedData.timeUsed ?? 0) * 1000);
                            this.duration = duration;
                        }

                        /** Returns the amount of time left in seconds.
                         * 
                         * @returns {number}
                         */
                        get timeLeft() {
                            return this.duration - (Date.now() - this.lastReset) / 1000;
                        }

                        /** Resets the timer.
                         * 
                         * @returns {void}
                         */
                        reset() {
                            this.lastReset = Date.now();
                        }

                        /** Displays the timer.
                         * 
                         * @returns {void}
                         */
                        draw() {
                            const ratio = Math.max(this.timeLeft / this.duration, 0);
                            const r = Math.min((1 - ratio) * 255 * 2, 255);
                            const g = Math.min(ratio * 255 * 2, 255);
                            ctx.save();
                            ctx.fillStyle = `rgb(${r}, ${g}, 0)`;
                            const red = window.App?.turnTimer?.timeLeft <= 5;
                            ctx.strokeStyle = red ? "rgba(255, 25, 25)" : "rgba(25, 25, 25)"; 
                            ctx.lineWidth = 4;
                            ctx.beginPath();
                            ctx.rect(width / 2 - 200, 15, 400 * ratio, 20);
                            ctx.fill();
                            ctx.beginPath();
                            ctx.rect(width / 2 - 200, 15, 400, 20);
                            ctx.stroke();
                            ctx.beginPath(); // apparently this does something
                            ctx.fillStyle = "#000000";
                            ctx.font = "15px Arial";
                            ctx.textAlign = "center";
                            ctx.textBaseline = "middle";
                            ctx.fillText("Score: " + window.App.score, width / 2, 25);
                            ctx.restore();
                        }
                    }

                    const GAP = 4;
                    const TS = Math.floor(Math.min(width, height) / 12);
                    const BOARD_Y = TS + 32;

                    const leftBoardCols = 4;
                    const leftBoardRows = Math.floor((height - BOARD_Y) / TS);
                    const rightBoardRows = 5;
                    const rightBoardCols = Math.floor((width * 0.58) / TS);

                    //total width of both boards then center
                    const totalBoardWidth = (leftBoardCols + rightBoardCols) * TS + GAP;
                    const offsetX = Math.floor((width - totalBoardWidth) / 2);

                    const leftBoardX  = offsetX;
                    const rightBoardX = offsetX + leftBoardCols * TS + GAP;
                    const rightBoardY = BOARD_Y;

                    const gridX = rightBoardX;
                    const gridY = BOARD_Y + rightBoardRows * TS + GAP;

                    this.rightGrid = new GridController(gridX, gridY, rightBoardCols * TS, (leftBoardRows - rightBoardRows) * TS, TS);
                    this.tileBoard = new TileBoard(leftBoardCols, leftBoardRows, rightBoardCols, rightBoardRows, leftBoardX, BOARD_Y, TS);

                    this.turnTimer = new TurnTimer(120);
                    this.turn = storedData.turn ?? 0;
                    this.matchedYet = storedData.matchedYet ?? false;
                    this.score = storedData.score ?? 0;

                    //trigger a one-time cascade check on the board so seam matches get cleared at startup(?)
                    this.tileBoard.swapInProgress = true;

                    //shake states
                    this.shake = {
                        x: 0,
                        y: 0
                    };
                    this.shakes = [];

                    //particle systems
                    this.matchBurst = new ParticleSystem({
                        add: function(x, y, color) {
                            for (let i = 0; i < 8; i++) {
                                const angle = (Math.PI * 2 * i) / 8 + Math.random() * 0.4;
                                const speed = 80 + Math.random() * 120;
                                this.particles.push(particlePool.get({
                                    position: {
                                        x,
                                        y
                                    },
                                    velocity: {
                                        x: Math.cos(angle) * speed / 10,
                                        y: Math.sin(angle) * speed / 10
                                    },
                                    size: 4 + Math.random() * 5,

                                    //hex to annoy xyzyyxx
                                    color: color || "#45B7D1",
                                    life: 80 + Math.random() * 40,
                                    acceleration: {
                                        x: 0,
                                        y: 2
                                    },
                                    angle: Math.random() * 360,
                                    rotation: (Math.random() - 0.5) * 400,
                                    clear: true,
                                    opacity: 1
                                }));
                            }
                        }
                    });

                    this.placeBurst = new ParticleSystem({
                        add: function(x, y, color) {
                            for (let i = 0; i < 20; i++) {
                                const angle = Math.random() * Math.PI * 2;
                                const speed = 30 + Math.random() * 120;
                                this.particles.push(particlePool.get({
                                    position: { 
                                        x, 
                                        y 
                                    },
                                    velocity: {
                                        x: Math.cos(angle) * speed / 10,
                                        y: Math.sin(angle) * speed / 10
                                    },
                                    size: 3 + Math.random() * 6,
                                    color: color || '#ffe066',
                                    life: 50 + Math.random() * 40,
                                    acceleration: { x: 0, y: 2 },
                                    angle: Math.random() * 360,
                                    rotation: (Math.random() - 0.5) * 400,
                                    clear: true,
                                    opacity: 1
                                }));
                            }
                        }
                    });

                    //ref
                    window.App = window.App || this;
                };

                /**
                * A partical. I was intially going to make them drawn by an offscreen secondary canvas, however they are to few to make this necessary 
                * 
                * @constructor
                * @param {object} config - configuration settings for the particle
                * @param {object} [config.position={}] - initial x and y coordinates
                * @param {number} [config.size=10] - diameter or side length
                * @param {string} [config.color] - fill color or hex code
                * @param {object} [config.velocity={}] - change in position per second
                * @param {number} [config.life=100] - duration until the particle expires
                * @param {object} [config.acceleration={}] - change in velocity per second
                * @param {number} [config.angle=0] - starting rotation in degrees
                * @param {number} [config.rotation=0] - rotational speed in degrees per second
                * @param {number} [config.opacity=1] - starting transparency level
                * @param {boolean} [config.clear=false] - whether to fade opacity over lifetime
                * @param {boolean} [config.collide=false] - whether physics collisions are enabled
                * @param {CanvasRenderingContext2D} [config.drawingMethod] - the canvas context used for rendering
                */
                function Particle(config) {
                    this.position = config.position || Object;
                    this.size = config.size || 10;
                    this.color = config.color;
                    this.velocity = config.velocity || Object;
                    this.life = config.life || 100;
                    this.acceleration = config.acceleration || Object;
                    this.angle = config.angle || 0;
                    this.rotation = config.rotation || 0;
                    this.opacity = config.opacity || 1;
                    this.clear = config.clear || false;
                    this.collide = config.collide || false;

                    //this.dT = deltaTime;
                    this.initialLife = config.life;
                    this.drawingMethod = config.drawingMethod || ctx;
                };

                /* Update a particle */
                Particle.prototype.update = function(DT) {
                    this.velocity.x += this.acceleration.x * DT;
                    this.velocity.y += this.acceleration.y * DT;

                    this.position.x += this.velocity.x * DT;
                    this.position.y += this.velocity.y * DT;

                    this.angle += this.rotation * DT;

                    if (this.clear !== false) {
                        this.opacity = Math.max(0, this.life / this.initialLife);
                    } else {
                        this.opacity = 1;
                    }

                    this.life -= 60 * DT;
                };

                /* Draw a particle */
                Particle.prototype.draw = function() {
                    this.drawingMethod.save();
                    this.drawingMethod.translate(this.position.x + this.size / 2, this.position.y + this.size / 2);
                    this.drawingMethod.rotate(this.angle / 180 * Math.PI);
                    this.drawingMethod.fillStyle = this.color;
                    this.drawingMethod.globalAlpha = this.opacity;
                    this.drawingMethod.fillRect(-this.size / 2, -this.size / 2, this.size, this.size);
                    this.drawingMethod.restore();
                };

                /* What happens when a particle dies? */
                Particle.prototype.die = function() {
                    return this.life < 0;
                };

                /* Run the particle */
                Particle.prototype.run = function(DT) {
                    this.draw();
                    this.update(DT);
                };

                /* Shallow copy of the particle for pooling */
                Particle.prototype.deepCopy = function(config) {
                    /* 
                        @Judges - This is really a shallow copy, lol. But deepCopy sounds cooler. This function copies a particle and resets it for future use. This is sometimes marginally faster or broadly faster than creating a brand new one and delting the old one, it depends on the context
                    */
                    this.position = {
                        x: (config.position && config.position.x) || 0,
                        y: (config.position && config.position.y) || 0
                    };
                    this.size = config.size || 10;
                    this.color = config.color || '#fff';
                    this.velocity = {
                        x: (config.velocity && config.velocity.x) || 0,
                        y: (config.velocity && config.velocity.y) || 0
                    };
                    this.life = (config.life !== undefined ? config.life : 100);
                    this.initialLife = this.life;

                    this.acceleration = {
                        x: (config.acceleration && config.acceleration.x) || 0,
                        y: (config.acceleration && config.acceleration.y) || 0
                    };
                    this.angle = config.angle || 0;
                    this.rotation = config.rotation || 0;
                    this.opacity = (config.opacity !== undefined ? config.opacity : 1);
                    this.clear = !!config.clear;
                    this.collide = !!config.collide;
                    this._pooledActive = true;
                };

                /**
                * manages a collection of reusable particle instances to minimize garbage collection
                * 
                * @param {number} [initialSize=400] - number of particles to preallocate in memory
                */
                class ParticlePool {
                    /* @Judges - The magic of a particle pool! */
                    constructor(initialSize = 400) {
                        this.pool = [];
                        for (let i = 0; i < initialSize; i++) {
                            //create a minimal particle instance
                            const p = new Particle({
                                position: {
                                    x: 0,
                                    y: 0
                                },
                                velocity: {
                                    x: 0,
                                    y: 0
                                },
                                size: 1,
                                color: '#000',
                                life: 0,
                                acceleration: {
                                    x: 0,
                                    y: 0
                                }
                            });
                            p._pooledActive = false;
                            this.pool.push(p);
                        }
                    }

                    //acquire a particle and initialize it with config
                    get(config) {
                        const p = this.pool.length ? this.pool.pop() : new Particle({
                            position: {
                                x: 0,
                                y: 0
                            },
                            velocity: {
                                x: 0,
                                y: 0
                            },
                            size: 1,
                            color: '#000',
                            life: 0,
                            acceleration: {
                                x: 0,
                                y: 0
                            }
                        });
                        p.deepCopy(config);
                        return p;
                    }

                    //release a particle back to the pool
                    release(p) {
                        //minimal reset to avoid keeping large nested references
                        p._pooledActive = false;
                        p.life = 0;
                        //zero velocities so reused state is clean
                        if (p.position) {
                            p.position.x = 0;
                            p.position.y = 0;
                        }
                        if (p.velocity) {
                            p.velocity.x = 0;
                            p.velocity.y = 0;
                        }
                        //push back into pool (no capacity limit here)
                        this.pool.push(p);
                    }
                }
                const particlePool = new ParticlePool(400);

                /**
                * Explodes a tile's pixel art by sampling its rendered pixels and firing each
                * one outward as an individual particle. Works by rendering the tile to a tiny
                * offscreen canvas via PixelArt.draw(), reading ImageData, then spawning one
                * particle per sampled pixel cluster.
                */
                class PixelArtExploder {

                    /**
                    * Fire the pixel-art explosion for a single tile.
                    *
                    * @param {Tile} tile - The tile to explode
                    * @param {number} tileSize - Rendered size of the tile in canvas px.
                    * @param {ParticleSystem} particleSystem - System that owns the particle array
                    * @param {number} [sampleStep=3] - Sample one pixel cluster per NN block.
                    */
                    static explode(tile, tileSize, particleSystem, sampleStep = 3) {

                        //offscreen canvas
                        const offscreen = document.createElement('canvas');
                        offscreen.width  = tileSize;
                        offscreen.height = tileSize;
                        const offCtx = offscreen.getContext('2d');

                        //center and draw
                        PixelArt.draw(
                            offCtx,
                            tile.colorIndex,
                            tile.sides,
                            tileSize / 2,
                            tileSize / 2,
                            tileSize,
                            1,
                            1,
                            false
                        );

                        //read pixel daata
                        const imageData = offCtx.getImageData(0, 0, tileSize, tileSize);
                        const pixels = imageData.data;
                        const centerX = tile.x;
                        const centerY = tile.y;

                        for (let py = 0; py < tileSize; py += sampleStep) {
                            for (let px = 0; px < tileSize; px += sampleStep) {
                                const i = (py * tileSize + px) * 4;
                                const r = pixels[i];
                                const g = pixels[i + 1];
                                const b = pixels[i + 2];
                                const a = pixels[i + 3];

                                //skip bg pixels
                                if (a < 40) continue;

                                //pixel's offset from the tile center
                                const dx = px - tileSize / 2;
                                const dy = py - tileSize / 2;
                                const dist = Math.hypot(dx, dy) || 1;

                                //base speed ramps up with distance from center so the
                                //outer ring flies further than the core
                                const baseSpeed = 50 + (dist / (tileSize / 2)) * 180 + Math.random() * 60;
                                const vx = (dx / dist) * baseSpeed * (0.6 + Math.random() * 0.8) / 10;
                                const vy = (dy / dist) * baseSpeed * (0.6 + Math.random() * 0.8) / 10- Math.random() * 4;

                                particleSystem.particles.push(particlePool.get({
                                    position: {
                                        //posiotion of pixel
                                        x: centerX - tileSize / 2 + px,
                                        y: centerY - tileSize / 2 + py
                                    },
                                    velocity:{ x: vx, y: vy },
                                    size: sampleStep + Math.random() * 2,
                                    color: `rgb(${r},${g},${b})`,
                                    life: 55 + Math.random() * 65,
                                    acceleration: { x: (Math.random() - 0.5) * 0.3, y: 5 },
                                    angle: Math.random() * 360,
                                    rotation: (Math.random() - 0.5) * 700,
                                    clear: true,
                                    opacity: 1
                                }));
                            }
                        }
                    }
                }

                /**
                * coordinates the creation, updating, and pooled recycling of multiple particles
                * 
                * @param {object} config - system configuration settings
                * @param {function} [config.add] - function defined to handle particle creation logic
                */
                function ParticleSystem(config) {
                    this.add = config.add || function() {};
                    //particles that clear when a level loads
                    this.particles = [];

                    //paricles that don't clear
                    this.foreverParticles = [];

                };

                /* Add a particle */
                ParticleSystem.prototype.addParticle = function() {
                    this.add();
                };
                ParticleSystem.prototype.col = function() {};

                /* Run a particle system. Fetch from pool, etc */
                ParticleSystem.prototype.run = function(DT) {
                    //scrap object if particles not being added
                    if (!this.add) {
                        this.addParticle();
                    }

                    //update normal particles (swap-pop removal)
                    for (let i = this.particles.length - 1; i >= 0; i--) {
                        const p = this.particles[i];
                        p.run(DT);
                        if (p.die()) {
                            //release to pool
                            particlePool.release(p);
                            //remove in O(1) by replacing with last element
                            const last = this.particles.pop();
                            if (i < this.particles.length) {
                                this.particles[i] = last;
                            }
                        }
                    }

                    //update foreverParticles (same pattern)
                    for (let i = this.foreverParticles.length - 1; i >= 0; i--) {
                        const p = this.foreverParticles[i];
                        p.run(DT);

                        if (p.collide) {
                            //
                        }
                        if (p.die()) {
                            particlePool.release(p);
                            const last = this.foreverParticles.pop();
                            if (i < this.foreverParticles.length) {
                                this.foreverParticles[i] = last;
                            }
                        }
                    }

                };
                
                ParticleSystem.prototype.update = function(DT) {
                    for (let i = this.particles.length - 1; i >= 0; i--) {
                        const p = this.particles[i];
                        p.update(DT);
                        if (p.die()) {
                            particlePool.release(p);
                            const last = this.particles.pop();
                            if (i < this.particles.length) this.particles[i] = last;
                        }
                    }
                };

                /**
                * creates a screen shake effect that diminishes over time
                * 
                * @param {number} n - the initial intensity or power of the shake
                * @param {object} app - the application state
                */
                function Shake(n, app) {
                    this.app = app;
                    //shake power
                    this.n = n;
                };
                Shake.prototype.active = function(increment) {
                    
                    //apply shake
                    this.app.shake.x = (Math.random() * 2 - 1) * this.n;
                    this.app.shake.y = (Math.random() * 2 - 1) * this.n;

                    //fade the shake
                    this.n -= 0.5;

                    if (this.n < 0) {
                        this.app.shake.x = 0;
                        this.app.shake.y = 0;
                        this.app.shakes.splice(increment, 1);
                    }
                };

                /**
                * adds a subtle screen shake using the existing Shake system
                * @param {number} [power=1] - shake strength in pixels
                */
                App.prototype.addShake = function(power = 1) {
                    /* @Judges - This consolidates the shake constructor into a reusable function. It uses some fun syntax as well! */
                    power = Number(power);
                    if (!isFinite(power) || power <= 0) return;
                    if (!this.shakes) this.shakes = [];

                    //merge into last shake to avoid spam
                    const last = this.shakes.length ? this.shakes[this.shakes.length - 1] : null;
                    if (last && typeof last.n === "number") {
                        last.n = Math.max(last.n, power);
                        return;
                    }
                    //cap shake list length
                    if (this.shakes.length > 6) {
                        this.shakes.length = 6;
                    }
                    this.shakes.push(new Shake(power, this));
                };

                /* Run the game */
                App.prototype.runGame = function(dt) {
                    ctx.fillStyle = "rgb(250, 250, 225)";
                    ctx.fillRect(0, 0, width, height);

                    //update shakes
                    for (let i = this.shakes.length - 1; i >= 0; i--) {
                        this.shakes[i].active(i);
                    }

                    //apply shake offset
                    ctx.save();
                    ctx.translate(Math.round(this.shake.x), Math.round(this.shake.y));

                    const b = this.tileBoard;
                    if (b) {
                        b.update(dt);
                        b.pool.update(dt);
                        if (!this.matchedYet) b.handleInput();
                        b.pool.handleInput();
                        b.draw();
                    }
                    if (this.rightGrid) {
                        this.rightGrid.update(dt);
                        this.rightGrid.pan();
                        this.rightGrid.draw();
                    }
                    
                    //run particles
                    this.matchBurst.run(dt);
                    this.placeBurst.update(dt);

                    //pool tiles drawn after grid so they always render on top
                    if (b) {
                        b.drawPool();
                    }

                    this.turnTimer.draw();

                    if (this.turnTimer.timeLeft <= 0) {
                        this.score -= b.pool.tiles.length; // penalize tiles still in pool
                        // if you went afk and didn't match in a turn, screw you lol
                        if (!this.matchedYet) this.score -= 20;
                        this.turnTimer.reset();
                        this.turn ++;
                        this.matchedYet = false;
                        b.pool.tiles = [];
                    }
                    if (inTutorial) {
                        this.turnTimer.reset();
                    }

                    // single unified border around everything
                    const b2 = this.tileBoard;
                    if (b2 && this.rightGrid) {
                        ctx.save();
                        const red = window.App?.turnTimer?.timeLeft <= 5;
                        ctx.strokeStyle = red ? "rgba(255, 25, 25)" : "rgba(25, 25, 25)";
                        ctx.lineWidth = 4;
                        ctx.strokeRect(
                            b2.boardX - 5,
                            b2.boardY - 5,
                            (b2.cols1 + b2.cols2) * b2.tileSize + 10,
                            b2.rows1 * b2.tileSize + 10
                        );
                        ctx.restore();
                    }
                    

                    ctx.restore();
                };

                /* Run the scenes */
                App.prototype.scenes = function(DT) {
                    switch (window.scene) {
                        case "intro": {
                            //only run intro in main window, not fullscreen popup
                            if (!window.opener) {
                                intro.run();

                                //when intro finishes, transition to menu
                                if (intro.prog > 360) {
                                    window.scene = "menu";
                                }
                            } else {
                                //in popup/fullscreen, skip intro
                                window.scene = "menu";
                            }
                            break;
                        }
                        case "menu": {
                            ctx.fillStyle = "rgb(5, 5, 25)";
                            ctx.fillRect(0, 0, width, height);
                            MenuScreen.draw(ctx, width, height, MenuScreen.t);
                            MenuScreen.t += 0.1;
                            ctx.fillStyle = "#00000022";
                            ctx.beginPath();
                            ctx.rect(width / 2 - 200, height / 2 + 50, 400, 100);
                            ctx.fill();
                            ctx.fillStyle = "#ffffff";
                            ctx.font = "40px Courier";
                            ctx.textAlign = "center";
                            ctx.textBaseline = "middle";
                            ctx.fillText("- Click to play -", width / 2, height / 2 + 100);
                            if (mouse.down) {
                                scene = "load";
                            }
                            break;
                        }
                        case "load": {
                            if (!cache.loaded) {
                                cache.load();
                                ctx.fillStyle = "rgb(255, 255, 255)";
                                ctx.fillRect(0, 0, width, height);
                                ctx.font = "25px Arial";
                                ctx.fillStyle = "rgb(35, 35, 35)";
                                ctx.fillText("Loading", 300, 300);
                            } else {
                                window.scene = "game";
                                App.call(this);
                                (function initTutorial() {
                                    const overlay = document.getElementById('tutorial-overlay');
                                    const closeBtn = document.getElementById('tutorial-close');
                                    const SEEN_KEY = 'axh-coc-tutorial-seen';
                                    if (localStorage.getItem(SEEN_KEY)) {
                                        inTutorial = false;
                                        return;
                                    } else {
                                        overlay.classList.remove('hidden');
                                    }

                                    closeBtn.addEventListener('click', () => {
                                        overlay.classList.add('hidden');
                                        localStorage.setItem(SEEN_KEY, '1');
                                        inTutorial = false;
                                    });
                                })();
                            }
                            break;
                        }
                        case "game": {
                            this.runGame(DT);
                            break;
                        }
                        case "win": {
                            ctx.fillStyle = "rgb(5, 5, 25)";
                            ctx.fillRect(0, 0, width, height);

                            ctx.save();
                            ctx.fillStyle = "rgb(255, 215, 0)";
                            ctx.font = "bold 72px Comfortaa";
                            ctx.textAlign = "center";
                            ctx.fillText("VICTORY!", width / 2, height / 2 - 80);

                            ctx.fillStyle = "rgb(245, 245, 245)";
                            ctx.font = "bold 36px Lato";

                            //
                            if (!this.winScoreEncoded) {
                                this.finalScore = Math.ceil(this.score);
                                this.encodedScore = btoa(Z.encode(this.finalScore));
                                textToCopy = this.encodedScore;
                                this.winScoreEncoded = true;
                            }

                            ctx.fillText("Final Score: " + this.finalScore, width / 2, height / 2);

                            ctx.font = "24px Lato";
                            ctx.fillText("Encoded: " + this.encodedScore, width / 2, height / 2 + 50);

                            ctx.font = "20px Lato";
                            ctx.globalAlpha = 0.7;
                            ctx.fillText("Click 'Copy Score' to copy your encoded score!", width / 2, height / 2 + 90);

                            // ctx.globalAlpha = 1;
                            // ctx.font = "24px Lato";
                            // ctx.fillText("Press SPACE to play again", width / 2, height / 2 + 130);
                            // ctx.restore();

                            //show copy button
                            document.getElementById('copyButton').style.display = "block";

                            if (keys[32]) {
                                document.getElementById('copyButton').style.display = "none";
                                this.winScoreEncoded = false;
                                this.resetGame();
                                window.scene = "game";
                            }
                            break;
                        }
                        case "death": {
                            ctx.fillStyle = "rgb(25, 5, 5)";
                            ctx.fillRect(0, 0, width, height);

                            ctx.save();
                            ctx.fillStyle = "rgb(255, 80, 80)";
                            ctx.font = "bold 72px Comfortaa";
                            ctx.textAlign = "center";
                            ctx.fillText("DEFEAT", width / 2, height / 2 - 80);

                            ctx.fillStyle = "rgb(245, 245, 245)";
                            ctx.font = "bold 36px Lato";
                            ctx.fillText("Score: " + Math.ceil(this.score), width / 2, height / 2);

                            ctx.font = "24px Lato";
                            ctx.globalAlpha = 0.7;
                            ctx.fillText("You ran out of health!", width / 2, height / 2 + 50);

                            ctx.globalAlpha = 1;
                            ctx.font = "24px Lato";
                            ctx.fillText("Press SPACE to try again", width / 2, height / 2 + 100);
                            ctx.restore();

                            if (keys[32]) {
                                //clear both flags
                                try {
                                    const rawSave = storage.getItem("dronemaker_save_v1");
                                    if (rawSave) {
                                        const save = JSON.parse(rawSave);
                                        save.isDead = false;
                                        save.playerHp = 10;
                                        storage.setItem("dronemaker_save_v1", JSON.stringify(save));
                                    }
                                } catch (e) {}

                                this.player.die = false;
                                this.resetGame();
                                window.scene = "game";
                            }
                            break;
                        }
                    }
                };

                /* Run the application */
                App.prototype.run = function(DT) {
                    this.scenes(DT);
                };

                /* Reset the entire App */
                App.prototype.resetGame = function() {
                    storedData = Object.create(null);
                    storage.removeItem("axh-coc-round-3--data");
                    App.call(this);
                };

                return App;
            })();

            //intiate a new game
            window.App = new Application({});

            //start a lightweight drawer for pool andd tilemap so they render on top
            (function startTileDraw() {
                /**
                * Background drawer used to render auxiliary layers (tile pool / tile map)
                * above the main loop. Runs on its own RAF.
                */
                function loop() {
                    requestAnimationFrame(loop);
                }
                //requestAnimationFrame(loop);
            })();


            console.createGraph("fps: low buffer", () => fps, {
                width: 240,
                height: 48,
                //note to self, this only should take in hex codes
                color: "#9ad0ff",

                buffer: 60,
                min: 0,
                max: 120,
            });


            //a render loop with a timestamp for dt updating @Judges
            /**
            * Main render function invoked by the RAF-driven loop. Updates timing values,
            * clears the canvas and runs the application `App.run` with computed delta time.
            * @param {DOMHighResTimeStamp|number} timestamp
            * @returns {void}
            */

            const render = (timestamp) => {
                try {
                    //prefer the rAF timestamp when present
                    const now = typeof timestamp === "number" ? timestamp : performance.now();

                    //dt in milliseconds, never negative
                    dtMs = Math.max(0, now - lastTime);
                    lastTime = now;

                    //dt in seconds (clamped to avoid huge jumps after tab hidden)
                    dt = Math.min(dtMs / 1000, 0.1);
                    fps = dtMs > 0 ? Math.round(1000 / dtMs) : fps;

                    //console.log("deltaTime", dt);

                    ctx.setTransform(dprVal, 0, 0, dprVal, 0, 0);
                    ctx.clearRect(0, 0, canvas.width / dprVal, canvas.height / dprVal);
                    //run the game based on deltatime
                    App.run(dt);

                    //@Judges DT makes this run smoothly on any device with any framerate

                    //reset events
                    mouse.released = false;
                    mouse.clicked = false;

                    //frameCount
                    frameCount++;

                    // Was mouse down
                    mouse.wasDown = mouse.down;
                } catch (e) {
                    console.error("Main loop error\n" + e.stack);
                }
            };

            //Replace interval with rAF
            let rafId = null;
            let running = true;

            //pause when tab hidden to avoid wasted frames @Judges
            document.addEventListener("visibilitychange", () => {
                running = !document.hidden;
                if (running && rafId === null) {
                    rafId = requestAnimationFrame(loop);
                }
                if (!running && rafId !== null) {
                    cancelAnimationFrame(rafId);
                    rafId = null;
                }
            });
            /**
            * main animation loop that requests frames and triggers rendering while the game is running
            * @param {number} now - the current timestamp provided by requestanimationframe
            * @returns {void}
            */
            /**
            * High level loop that guards running state and schedules the next RAF.
            * @param {number} now - The current timestamp from requestAnimationFrame.
            * @returns {void}
            */
            function loop(now) {
                //if (!debug.freeze) {
                if (!running) {
                    rafId = null;
                    return;
                }
                render(now);
                rafId = requestAnimationFrame(loop);
                //}
                //console.info(debug.freeze);
            }

            //start
            if (rafId) cancelAnimationFrame(rafId);
            rafId = requestAnimationFrame(loop);

            // if (loopTimer) window.clearInterval(loopTimer);
            // var loopTimer = window.setInterval(render, 1000/60);

            window.addEventListener("keydown", (e) => {
                if (e.which === 192) {
                    showThumb();
                }
                e.preventDefault();
                keys[e.which] = true;
            });
            window.addEventListener("keyup", (e) => {
                if (e.which === 192) {
                    hideThumb();
                }
                e.preventDefault();
                keys[e.which] = false;
            });

            //add mouse events
            window.addEventListener("click", (e) => {
                //e.preventDefault();
                mouse.clicked = true;
            });
            window.addEventListener("mouseup", (e) => {
                //e.preventDefault();
                mouse.released = true;
                mouse.down = false;
            });
            window.addEventListener("mousedown", (e) => {
                //e.preventDefault();
                mouse.down = true;
            });
            window.addEventListener("mousedown", (e) => {
                if (e.button === 2) {
                    mouse.rightDown = true;
                    mouse.rightReleased = false;
                } else if (e.button === 0) {
                    mouse.down = true;
                    mouse.released = false;
                }
            });

            window.addEventListener("mouseup", (e) => {
                if (e.button === 2) {
                    mouse.rightDown = false;
                    mouse.rightReleased = true;
                } else if (e.button === 0) {
                    mouse.down = false;
                    mouse.released = true;
                }
            });
            window.addEventListener("contextmenu", (e) => {
                //disableContextMenu to allow for right clicks in game
                //e.preventDefault();
            });

            //prevents focus spam
            window.addEventListener("blur", () => {
                mouse.down = false;
                mouse.rightDown = false;
            });
            //store mouse in world coordinates
            window.addEventListener("mousemove", (e) => {
                mouse.screenX = e.clientX;
                mouse.screenY = e.clientY;

                //convert screen to world CORRECTLY
                const worldPos = screenToWorld(e.clientX, e.clientY);
                mouse.x = worldPos.x;
                mouse.y = worldPos.y;
            });

            /**
            * converts world coordinates to screen coordinates by applying camera translation and scale
            * @param {number} worldx - the horizontal position in the game world
            * @param {number} worldy - the vertical position in the game world
            * @returns {object} an object containing the calculated x and y screen coordinates
            */
            function worldToScreen(worldX, worldY) {
                const totalScale = App.cam.z * displayScale;

                //apply camera translation
                const camX = worldX - App.cam.x + App.cam.align.x - (App.shake.x || 0);
                const camY = worldY - App.cam.y + App.cam.align.y - (App.shake.y || 0);

                //then apply scaling
                const screenX = camX * totalScale;
                const screenY = camY * totalScale;

                return {
                    x: screenX,
                    y: screenY
                };
            }

            //get fullscreen icon
            const button = document.getElementById("fullscreen");

            //Event
            window.addEventListener("resize", function() {
                if (typeof minimap !== "undefined" && minimap.init) minimap.init();
            });

            // Back to last placed tile
            document.querySelector("#back").addEventListener("click", e => {
                window.App.rightGrid.panToLastPlaced();
            });

            // Save to local storage
            document.querySelector("#save").addEventListener("click", e => {
                try {
                    // basically what this does is it takes only the sides and colorIndex data,
                    // to avoid storing too much
                    const tileMapper = ({ sides, colorIndex }) => ({ sides, colorIndex });

                    // Compile all the data into a single object
                    const data = {
                        tileBoard: window.App.tileBoard.tiles.map(
                            row => row.map(tileMapper)
                        ),
                        pool: window.App.tileBoard.pool.tiles.map(tileMapper),
                        rightGrid: window.App.rightGrid.tiles.map(
                            ({ row, col, tile }) => ({ row, col, tile: tileMapper(tile) })
                        ),
                        turn: window.App.turn,
                        timeUsed: window.App.turnTimer.duration - window.App.turnTimer.timeLeft,
                        matchedYet: window.App.matchedYet,
                        score: window.App.score,
                    };
                    
                    storage.setItem("axh-coc-round-3--data", JSON.stringify(data));

                    alert("Saved!");
                } catch (e) {
                    alert("Oops, something went wrong, and we don't know what. :/");
                }
            });

            document.querySelector("#endturn").addEventListener("click", () => {
                if (window.App.tileBoard.pool.tiles.length) {
                    alert("You still have tiles in the tile pool. Clear them before ending your turn!");
                } else if (!window.App.matchedYet) {
                    alert("You haven't made a match yet. Make one before ending your turn!");
                } else {
                    window.App.turnTimer.reset();
                    window.App.turn ++;
                    window.App.matchedYet = false;
                }
            })

            document.querySelector("#reload").addEventListener("click", () => {
                const prmpt = "Are you sure you want to reset? You will lose all your progress.";
                if (confirm(prmpt)) {
                    App.resetGame();
                }
            });

            //intiate...
            /**
            * Open the current document in a new window (simple fullscreen mode). Copies
            * the current DOM HTML into the new window and sets a session flag to skip the menu.
            * @returns {void}
            */
            const openInFullscreen = () => {
                sessionStorage.setItem('skipMenu', 'true');

                const w = window.open();
                w.document.open();
                w.document.write(
                    `<!doctype html><html>${document.querySelector("html").innerHTML}</html>`,
                );
                w.document.close();
            };

            //add the event listener
            button.addEventListener("click", openInFullscreen);


            firstFrame = false;

            return {
                Application,
                render,
            };
        })();

        //document.getElementById("thumb").style.display = "none";
        document.getElementById("game").style.border = "none";
    </script>
</html> 










